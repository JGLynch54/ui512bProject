Microsoft (R) Macro Assembler (x64) Version 14.44.35215.0   08/25/25 20:37:28
ui512b.asm						     Page 1 - 1


				;
				;			ui512b
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			File:			ui512b.asm
				;			Author:			John G. Lynch
				;			Legal:			Copyright @2024, per MIT License included
				;			Date:			June 11, 2024
				;

								INCLUDE			legalnotes.inc
			      C 
			      C IFNDEF		legalnotes
 = 00000001		      C legalnotes	EQU		1
			      C .LIST
			      C ;			legalnotes
			      C ;
			      C ;			File:			legalnotes.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			August 20, 2025
			      C ;
			      C ;
			      C ;			Notes:
			      C ;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
			      C ;
			      C ;				ui512a provides basic operations: zero, copy, compare, add, subtract.
			      C ;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
			      C ;               ui512md provides multiply and divide.
			      C ;
			      C ;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
			      C ;				(currently using VS Community 2022 17.14.10)
			      C ;
			      C ;				It provides external signatures that allow linkage to C and C++ programs,
			      C ;				where a shell/wrapper could encapsulate the methods as part of an object.
			      C ;
			      C ;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
			      C ;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
			      C ;
			      C ;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
			      C ;
			      C ;				If processor extensions are used, the caller must align the variables declared and passed
			      C ;				on the appropriate byte boundary (e.g. alignas 64 for 512)
			      C ;
			      C ;				This module is very light-weight (less than 2K bytes) and relatively fast,
			      C ;				but is not intended for all processor types or all environments. 
			      C ;
			      C ;				Use for private (hobbyist), or instructional, or as an example for more ambitious projects
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			MIT License
			      C ;
			      C ;			Copyright (c) 2024 John G. Lynch
			      C ;
			      C ;				Permission is hereby granted, free of charge, to any person obtaining a copy
			      C ;				of this software and associated documentation files (the "Software"), to deal
			      C ;				in the Software without restriction, including without limitation the rights
			      C ;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			      C ;				copies of the Software, and to permit persons to whom the Software is
			      C ;				furnished to do so, subject to the following conditions:
			      C ;
			      C ;				The above copyright notice and this permission notice shall be included in all
			      C ;				copies or substantial portions of the Software.
			      C ;
			      C ;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			      C ;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			      C ;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			      C ;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			      C ;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			      C ;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			      C ;				SOFTWARE.
			      C ;
			      C ENDIF			; legalnotes
			      C 
								INCLUDE			compile_time_options.inc
			      C ;			compile_time_options
			      C ;
			      C ;			File:			compile_time_options.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License included
			      C ;			Date:			August 20, 2025
			      C ;
			      C ;
			      C IFNDEF							compile_time_options_INC
 = 1			      C compile_time_options_INC		EQU			<1>
			      C 
			      C 				INCLUDE			legalnotes.inc
			      C 
			      C IFNDEF		legalnotes
			      C ENDIF			; legalnotes
			      C 
			      C 
			      C ;			Configuration choices
			      C ;
			      C ;	Note: Choosing these options requires knowledge of the target machine CPU model. If you are unsure of the capabiites of the target machine CPU,
			      C ;	You can use the "CPU-Z" tool. https://www.cpuid.com/downloads/cpu-z/cpu-z_2.09-en.exe 
			      C ;	Basically, Intel Skylake and later can use "Z", Haswell and later can use BMI2, etc. 
			      C ;	Too many processors, options, vendors for me to list here. Go to the CPU vendor specifications, or use the tool to inform your choice.
			      C ;
			      C ;	Note: This is intended to be a mutually exclusive choice (UseZ thru UseQ).
			      C ;	However, the coding of the options selects the "highest" one used and ignores the rest ( If __UseZ ... ELSEIF __UseY ... )
			      C 
 = 00000001		      C __UseZ			EQU				1									; Use AVX4 processor features (512 bit registers and instructions)
 = 00000000		      C __UseY			EQU				0									; Use AVX2 processor features (256 bit registers and instructions)
 = 00000000		      C __UseX			EQU				0									; Use SIMD/SSE processor features (128 bit registers and instructions)
 = 00000000		      C __UseQ			EQU				0									; Do not use extensions, use standard x64 bit registers and instructions
			      C ;
 = 00000001		      C __UseBMI2		EQU				1									; Bit manipulation instructions (Haswell and later) ref:https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set
			      C ;
 = 00000001		      C __VerifyRegs	EQU				1									; in debug mode, or with unit tests, define routine to verify non-volatile regs 
 = 00000000		      C __CheckAlign	EQU				0									; User is expected to pass arguments aligned on 64 byte boundaries, 
			      C ;																	; This setting enforces that with a check. It should not be necessary, but included to help debugging
			      C 
			      C ENDIF			; compile_time_options_INC
			      C 
								INCLUDE			ui512aMacros.inc
			      C ;
			      C ;			ui512aMacros
			      C ;
			      C ;			File:			ui512aMacros.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			May 13, 2024
			      C ;
			      C 
			      C IFNDEF			ui512aMacros_INC
 = 1			      C ui512aMacros_INC EQU			<1>
			      C 
			      C 				INCLUDE			legalnotes.inc
			      C 
			      C IFNDEF		legalnotes
			      C ENDIF			; legalnotes
			      C 
			      C 
			      C ;           header file equivalent extern declarations
			      C ;			EXTERN "C" signatures (from ui512a.asm)
			      C 
			      C ;	// void zero_u ( u64* destarr ); 
			      C ;	// fill supplied 512bit (8 QWORDS) with zero
			      C EXTERNDEF		zero_u:PROC
			      C 
			      C 
			      C ;	// void copy_u ( u64* destarr, u64* srcarr );
			      C ;	// copy supplied 512bit (8 QWORDS) source to supplied destination
			      C EXTERNDEF		copy_u:PROC
			      C 
			      C ;	// void set_uT64 ( u64* destarr, u64 value );
			      C ;	// set supplied destination 512 bit to supplied u64 value
			      C EXTERNDEF		set_uT64:PROC
			      C 
			      C ;	// s16 compare_u ( u64* lh_op, u64* rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_u:PROC
			      C 
			      C ;	// s16 compare_uT64 ( u64* lh_op, u64 rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand (value)
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_uT64:PROC
			      C 
			      C ;	// s16 add_u ( u64* sum, u64* addend1, u64* addend2 );
			      C ;	// add supplied 512bit (8 QWORDS) sources, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u:PROC
			      C 
			      C ;	// s16 add_uT64 ( u64* sum, u64* addend1, u64 addend2 );
			      C ;	// add 64bit QWORD (value) to supplied 512bit (8 QWORDS), place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_uT64:PROC
			      C 
			      C ;	// s16 sub_u ( u64* difference, u64* left operand, u64* right operand );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u:PROC
			      C 
			      C ;	// s16 sub_uT64( u64* difference, u64* left operand, u64 right operand );
			      C ;	// subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_uT64:PROC
			      C ;
			      C 
			      C ;           Some coding shortcuts
 = ZMMWORD PTR		      C ZM_PTR			EQU				ZMMWORD PTR 
 = YMMWORD PTR		      C YM_PTR			EQU				YMMWORD PTR
 = XMMWORD PTR		      C XM_PTR			EQU				XMMWORD PTR
 = QWORD PTR		      C Q_PTR			EQU				QWORD PTR
 = DWORD PTR		      C D_PTR			EQU				DWORD PTR
 = WORD PTR		      C W_PTR			EQU				WORD PTR
 = BYTE PTR		      C B_PTR			EQU				BYTE PTR
 = DWORD BCST		      C m32BCST			EQU				DWORD BCST
 = QWORD BCST		      C m64BCST			EQU				QWORD BCST
			      C LPVOID			TYPEDEF			PTR VOID
			      C ;			mask codes (for compares using instructions like VPCMPUQ)
 = 00000000		      C CPEQ			EQU				0
 = 00000001		      C CPLT			EQU				1
 = 00000002		      C CPLE			EQU				2
 = 00000003		      C CPFALSE			EQU				3
 = 00000004		      C CPNE			EQU				4
 = 00000005		      C CPGE			EQU				5
 = 00000006		      C CPGT			EQU				6
 = 00000007		      C CPTRUE			EQU				7
			      C 
			      C ;
			      C ; MemConstants <none>
			      C ;
			      C ;		Define useful constants
			      C ;		Note: this must be first in a data segment aligned (64)
			      C ;
			      C MemConstants	MACRO
			      C ; 
			      C qOnes			QWORD           8 DUP (0ffffffffffffffffh)
			      C zeroQ			DQ				0
			      C 
			      C ;		Return codes commonly used.	
			      C retcode_zero	EQU				0
			      C retcode_one		EQU				1
			      C retcode_neg_one	EQU				-1
			      C ;		Sometimes need to get it from memory, not an immediate value. So:
			      C ret_zero		DD				retcode_zero						
			      C ret_one			DD				retcode_one
			      C ret_neg_one		DD				retcode_neg_one
			      C 
			      C ;		Masks commonly used
			      C ;		Record form, which can be used as immediate values. Example: OR	R8D, MASK kMask.b8
			      C kMask			RECORD			b8:1, b7:1, b6:1, b5:1, b4:1, b3:1, b2:1, b1:1, b0:1
			      C ;		And as memory, for when immediate simply wont do
			      C mskB0			DB				1
			      C mskB1			DB				2
			      C mskB2			DB				4
			      C mskB3			DB				8
			      C mskB4			DB				16
			      C mskB5			DB				32
			      C mskB6			DB				64
			      C mskB7			DB				128
			      C mskAll8			DB				255
			      C 				ENDM
			      C 
			      C ;==================================================================================================
			      C ;           Notes on x64 calling conventions        specifically "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The callers first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address
			      C ; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ; return (if any) is in EAX
			      C ;
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile,
			      C ;	and do not need to be saved
			      C ;  ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C ;==================================================================================================
			      C 
			      C ;==================================================================================================
			      C ; Selected macros from "macamd64.inc" (c) Microsoft Corporation
			      C ;	These macros generate .xdata and .pdata entries in the executable image file.
			      C ;	The entries assist in exception and debugging; helping 'unwind' operations.
			      C ;	Only a few macros are included, and are reformatted to match coding style:
			      C ;	indents and capitalization.
			      C ;
			      C ; LEAF_ENTRY <Name>, <Section>
			      C ;
			      C ; Macro Description:
			      C ;
			      C ;   This macro indicates the beginning of a leaf function.
			      C ;
			      C ;   A leaf function is one that DOES NOT:
			      C ;
			      C ;   - manipulate non-volatile registers
			      C ;   - manipulate the stack pointer
			      C ;   - call other functions
			      C ;   - reference an exception handler
			      C ;   - contain a prologue
			      C ;   - have any unwind data associated with it
			      C ;
			      C ; Arguments:
			      C ;
			      C ;   Name - Supplies the name of the function
			      C ;
			      C ;   Section - Supplies the name of the section within which the function
			      C ;             is to appear
			      C ;
			      C Leaf_Entry		MACRO			Name, Section
			      C Section			SEGMENT			PARA 'CODE'
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				PUBLIC			Name
			      C Name			PROC			FRAME
			      C 				.ENDPROLOG
			      C 				ENDM
			      C 
			      C ;
			      C ; LEAF_END <Name>, <Section>
			      C ;
			      C ; Macro Description:
			      C ;
			      C ;   This macro indicates the end of a leaf function.  It must be paired
			      C ;   with a LEAF_ENTRY macro that includes matching Name and Section
			      C ;   parameters.
			      C ;
			      C ; Arguments:
			      C ;
			      C ;   Name - Supplies the name of the function.  Must match that supplied to
			      C ;          the corresponding LEAF_ENTRY macro.
			      C ;
			      C ;   Section - Supplies the name of the section within which the function
			      C ;             is to appear.  Must match that supplied to the corresponding
			      C ;             LEAF_ENTRY macro.
			      C ;
			      C Leaf_End		MACRO			Name, Section
			      C Name			ENDP
			      C Section			ENDS
			      C 				ENDM
			      C 
			      C ;===========================================================================================
			      C ;          Local macros
			      C ;===========================================================================================
			      C 
			      C ;
			      C ; CheckAlign <RAddr>
			      C ;
			      C ;			Test passed variable addresses for 64 byte alignment
			      C ;			Note: Better performance if this is off, but for debugging, maybe have it on
			      C ;
			      C 
			      C CheckAlign		MACRO			Raddr
			      C 				LOCAL			ok
			      C 	IF	__CheckAlign
			      C 				TEST			Raddr, 63							; Is specified param aligned 64?
			      C 				JZ				ok									; Yes, passes test, continue
			      C 				INT				13									; No? fails, break (can substitute other exception handling)
			      C ok:
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ; VerifyRegs <none>
			      C ;
			      C ;			If option is on, generate a function, callable by unit test routines, 
			      C ;				to save non-volatile registers in passed structure.
			      C ;
			      C IF	__VerifyRegs
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* regstruct)
			      C ;			reg_verify		-	copy non-volatile regs into callers struct of nine qwords) intended for unit tests to verify non-volatile regs are not changed
			      C ;			Prototype:		-	void reg_verify( uu64* regstruct);
			      C ;			regstruct		-	Address of 9 QWORDS in a struct where regs will be copied (in RCX)
			      C ; //			reg_verify		-	save non-volatile regs for verification (debug)
			      C ; //			Prototype		-	void reg_verify ( u64* reg struct)
			      C EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* reg struct)
			      C 
			      C VerifyRegs		MACRO
			      C 				Leaf_Entry		reg_verify, ui512
			      C 				MOV				Q_PTR [ RCX ] [ 0 * 8 ], R12
			      C 				MOV				Q_PTR [ RCX ] [ 1 * 8 ], R13
			      C 				MOV				Q_PTR [ RCX ] [ 2 * 8 ], R14
			      C 				MOV				Q_PTR [ RCX ] [ 3 * 8 ], R15
			      C 				MOV				Q_PTR [ RCX ] [ 4 * 8 ], RDI
			      C 				MOV				Q_PTR [ RCX ] [ 5 * 8 ], RSI
			      C 				MOV				Q_PTR [ RCX ] [ 6 * 8 ], RBX
			      C 				MOV				Q_PTR [ RCX ] [ 7 * 8 ], RBP
			      C 				MOV				Q_PTR [ RCX ] [ 8 * 8 ], RSP
			      C 				RET
			      C 				Leaf_End		reg_verify, ui512
			      C 				ENDM
			      C ENDIF
			      C 
			      C ;
			      C ;			Zero a 512 bit destination, conditional assembly based on configuration parameters
			      C ;
			      C Zero512			MACRO			dest:REQ
			      C 	IF		__UseZ
			      C 				CheckAlign		dest
			      C 				VPXORQ			ZMM31, ZMM31, ZMM31
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				VPXORQ			YMM4, YMM4, YMM4
			      C 				FOR				idx, < 0, 4 >
			      C 				VMOVDQA64		YM_PTR [ dest ] [ idx * 8 ], YMM4
			      C 				ENDM
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				PXOR			XMM4, XMM4
			      C 				FOR				idx, < 0, 2, 4, 6 >
			      C 				MOVDQA			XM_PTR [ dest ] [ idx * 8 ], XMM4
			      C 				ENDM		
			      C 	ELSE
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ;			Zero a 512 bit destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Zero512Q		MACRO			dest:REQ
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ;
			      C ;			Copy a 512 bit source to destination, conditional assembly based on configuration parameters
			      C ;
			      C Copy512			MACRO			dest:REQ, src:REQ
			      C 	IF		__UseZ 
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		ZMM31, ZM_PTR [ src ]
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		YMM4, YM_PTR [ src + 0 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			      C 				VMOVDQA64		YMM5, YM_PTR [ src ] [ 4 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 4 * 8 ], YMM5
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 0 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 0 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 2 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 2 * 8 ], XMM3
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 4 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 4 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 6 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 6 * 8 ], XMM3
			      C 	ELSE
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ;			Copy a 512 bit source to destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Copy512Q		MACRO			dest:REQ, src:REQ
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ENDIF	; ui512aMacros_INC
			      C 
								INCLUDE			ui512bMacros.inc
			      C ;
			      C ;			ui512bMacros
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			File:			ui512bMacros.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			June 11, 2024
			      C ;	
			      C 
			      C IFNDEF			ui512bMacros_INC
 = 1			      C ui512bMacros_INC EQU		<1>
			      C 
			      C 				INCLUDE			legalnotes.inc
			      C 
			      C IFNDEF		legalnotes
			      C ENDIF			; legalnotes
			      C 
			      C 
			      C ;           header file equivalent extern declarations
			      C ;			EXTERN "C" signatures (from ui512b.asm)
			      C 
			      C ;   // void shr_u ( u64* destination, u64* source, u16 bits_to_shift )
			      C ;   // shift supplied source 512bit (8 QWORDS) right, put in destination
			      C EXTERNDEF		shr_u:PROC
			      C 
			      C ;   // void shl_u ( u64* destination, u64* source, u16 bits_to_shift );
			      C ;   // shift supplied source 512bit (8 QWORDS) left, put in destination
			      C EXTERNDEF		shl_u:PROC
			      C 
			      C ;   // void and_u ( u64* destination, u64* lh_op, u64* rh_op );
			      C ;   // logical 'AND' bits in lh_op, rh_op, put result in destination
			      C EXTERNDEF		and_u:PROC
			      C 
			      C ;   // logical 'OR' bits in lh_op, rh_op, put result in destination
			      C ;   // void or_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		or_u:PROC
			      C 
			      C ;   // logical 'XOR' bits in lh_op, rh_op, put result in destination
			      C ;   // void xor_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		xor_u:PROC
			      C 
			      C ;   // logical 'NOT' bits in source, put result in destination
			      C ;	// void not_u( u64* destination, u64* source);
			      C EXTERNDEF		not_u:PROC
			      C 
			      C ;   // find most significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 msb_u( u64* );
			      C ;   // returns: -1 if no most significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit).
			      C ;	//			a returned 511 means bit63 of the first word; (the left most bit).	
			      C EXTERNDEF		msb_u:PROC
			      C 
			      C ;   // find least significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 lsb_u( u64* );
			      C ;   // returns: -1 if no least significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit).
			      C ;	//			a returned 511 means bit63 of the first word; (the left most bit).	
			      C EXTERNDEF		lsb_u:PROC
			      C 
			      C ;==================================================================================================
			      C 
			      C ; Local macros
			      C 
			      C ; Each word is shifted right, and the bits shifted out are ORd into the next (less significant) word.
			      C ; RCX holds the number of bits to shift right, RBX holds the 64 bit complement for left shift.
			      C ShiftOrR		MACRO			lReg, rReg
			      C 				SHLX			RDX, lReg, RBX					; shift 'bottom' bits to top
			      C 				SHRX			rReg, rReg, RCX					; shift target bits right (leaving zero filled bits at top)
			      C 				OR				rReg, RDX						; OR in new 'top' bits
			      C 				ENDM
			      C 
			      C ; Each word is shifted left, and the bits shifted out are ORd into the next (more significant) word.
			      C ; RCX holds the number of bits to shift left, RBX holds the 64 bit complement for right shift.
			      C ShiftOrL		MACRO			lReg, rReg
			      C 				SHRX			RDX, lReg, RBX					; shift 'top' bits to bottom
			      C 				SHLX			rReg, rReg, RCX					; shift target bits left (leaving zero filled bits at bottom)
			      C 				OR				rReg, RDX						; OR in new 'bottom' bits
			      C 				ENDM
			      C 
			      C ENDIF			; ui512bMacros_INC
			      C 
								OPTION			casemap:none

 00000000			ui512D			SEGMENT			'RODATA' ALIGN (64)				; Declare a data segment. Read only. Aligned 64.

				; Note: all data here is read-only, so can be shared between multiple threads
					IF __UseZ		; Only need these tables if using zmm regs

				; Note: storage of qwords in ZMM regs is in 'reverse' order, with the lowest index holding the most significant qword
				;			so index 0 holds bits 511-448, index 7 holds bits 63-0
				; But when the ZMM reg is stored to memory, the order is 'normal', with the lowest address holding the most significant qword

				; table of indices for permuting words in a zmm reg to achieve right shifts by words
 00000000			ShiftPermuteRt	QWORD			0, 1, 2, 3, 4, 5, 6, 7			; identity permute for shift left/right by words
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
	   0000000000000004
	   0000000000000005
	   0000000000000006
	   0000000000000007
 00000040  0000000000000000					QWORD			0, 0, 1, 2, 3, 4, 5, 6			; shift right by one word
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
	   0000000000000004
	   0000000000000005
	   0000000000000006
 00000080  0000000000000000					QWORD			0, 0, 0, 1, 2, 3, 4, 5			; shift right by two words
	   0000000000000000
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
	   0000000000000004
	   0000000000000005
 000000C0  0000000000000000					QWORD			0, 0, 0, 0, 1, 2, 3, 4			; shift right by three words
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
	   0000000000000004
 00000100  0000000000000000					QWORD			0, 0, 0, 0, 0, 1, 2, 3			; shift right by four words
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
 00000140  0000000000000000					QWORD			0, 0, 0, 0, 0, 0, 1, 2			; shift right by five words
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000001
	   0000000000000002
 00000180  0000000000000000					QWORD			0, 0, 0, 0, 0, 0, 0, 1			; shift right by six words
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000001
 000001C0  0000000000000000					QWORD			0, 0, 0, 0, 0, 0, 0, 0			; shift right by seven words
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000

				; table of indices for permuting words in a zmm reg to achieve left shifts by words
 00000200			ShiftPermuteLt	QWORD			0, 1, 2, 3, 4, 5, 6, 7			; identity permute for shift left/right by words
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
	   0000000000000004
	   0000000000000005
	   0000000000000006
	   0000000000000007
 00000240  0000000000000001					QWORD			1, 2, 3, 4, 5, 6, 7, 0			; shift left by one word
	   0000000000000002
	   0000000000000003
	   0000000000000004
	   0000000000000005
	   0000000000000006
	   0000000000000007
	   0000000000000000
 00000280  0000000000000002					QWORD			2, 3, 4, 5, 6, 7, 0, 0			; shift left by two words
	   0000000000000003
	   0000000000000004
	   0000000000000005
	   0000000000000006
	   0000000000000007
	   0000000000000000
	   0000000000000000
 000002C0  0000000000000003					QWORD			3, 4, 5, 6, 7, 0, 0, 0			; shift left by three words
	   0000000000000004
	   0000000000000005
	   0000000000000006
	   0000000000000007
	   0000000000000000
	   0000000000000000
	   0000000000000000
 00000300  0000000000000004					QWORD			4, 5, 6, 7, 0, 0, 0, 0			; shift left by four words
	   0000000000000005
	   0000000000000006
	   0000000000000007
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
 00000340  0000000000000005					QWORD			5, 6, 7, 0, 0, 0, 0, 0			; shift left by five words
	   0000000000000006
	   0000000000000007
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
 00000380  0000000000000006					QWORD			6, 7, 0, 0, 0, 0, 0, 0			; shift left by six words
	   0000000000000007
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
 000003C0  0000000000000007					QWORD			7, 0, 0, 0, 0, 0, 0, 0			; shift left by seven words	
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
					ENDIF
				; Generate memory resident constants (still aligned 64)
								MemConstants
 00000400  00000008 [	     1	qOnes			QWORD           8 DUP (0ffffffffffffffffh)
	    FFFFFFFFFFFFFFFF
	   ]
 00000440		     1	zeroQ			DQ				0
	   0000000000000000
 = 00000000		     1	retcode_zero	EQU				0
 = 00000001		     1	retcode_one		EQU				1
 =-00000001		     1	retcode_neg_one	EQU				-1
 00000448 00000000	     1	ret_zero		DD				retcode_zero						
 0000044C 00000001	     1	ret_one			DD				retcode_one
 00000450 FFFFFFFF	     1	ret_neg_one		DD				retcode_neg_one
 00000454 01		     1	mskB0			DB				1
 00000455 02		     1	mskB1			DB				2
 00000456 04		     1	mskB2			DB				4
 00000457 08		     1	mskB3			DB				8
 00000458 10		     1	mskB4			DB				16
 00000459 20		     1	mskB5			DB				32
 0000045A 40		     1	mskB6			DB				64
 0000045B 80		     1	mskB7			DB				128
 0000045C FF		     1	mskAll8			DB				255
					IF __UseZ		; Only need these tables if using zmm regs
						
				; When shifting, some words become zero,table of masks for zeroing words when shifting right
 0000045D FF FE FC F8 F0	ShiftMaskRt		DB				0ffh, 0feh, 0fch, 0f8h, 0f0h, 0e0h, 0c0h, 080h
	   E0 C0 80

				; When shifting, some words become zero,table of masks for zeroing words when shifting left
 00000465 FF 7F 3F 1F 0F	ShiftMaskLt		DB				0ffh, 07fh, 03fh, 01fh, 0fh, 07h, 03h, 01h	
	   07 03 01
					ENDIF

				; end of memory resident constants
				; end of data segment
 0000046D			ui512D			ENDS											; end of data segment


				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			shr_u		-	shift supplied source 512bit (8 QWORDS) right, put in destination
				;			Prototype:		void shr_u( u64* destination, u64* source, u32 bits_to_shift)
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			bits		-	Number of bits to shift. Will fill with zeros, truncate those shifted out (in R8W)
				;			returns		-	nothing (0)
				;			Note: unwound loop(s). More instructions, but fewer executed (no loop save, setup, compare loop), faster, fewer regs used

								Leaf_Entry		shr_u, ui512
 00000000		     1	ui512			SEGMENT			PARA 'CODE'
 00000000  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000010		     1	shr_u			PROC			FRAME
								CheckAlign		RCX								; (OUT) destination of shifted 8 QWORDs
								CheckAlign		RDX								; (IN)	source of 8 QWORDS

 00000010  66| 41/ 81 F8					CMP				R8W, 512						; handle edge case, shift 512 or more bits
	   0200
 00000016  7C 0D						JL				@F
								Zero512			RCX								; zero destination
 00000018  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000001E  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 00000024  C3							RET
 00000025  49/ 81 E0		@@:				AND				R8, 511							; ensure no high bits above shift count
	   000001FF
 0000002C  75 12						JNZ				@F								; handle edge case, zero bits to shift
 0000002E  48/ 3B CA						CMP				RCX, RDX
 00000031  74 0C						JE				@@ret							; destination is the same as the source: no copy needed
								Copy512			RCX, RDX						; no shift, just copy (destination, source already in regs)
 00000033  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 00000039  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 0000003F  C3			@@ret:			RET
 00000040			@@:

					IF	__UseZ
 00000040  62 61 FD 48/ 6F					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]			; load the 8 qwords into zmm reg (note: word order)
	   3A
 00000046  49/ 8D 00						LEA				RAX, [ R8 ]
 00000049  66| 83 E0 3F						AND				AX, 03fh						; limit shift count to 63 (shifting bits only here, not words)
 0000004D  74 19						JZ				@F								; if true, must be multiple of 64 bits to shift, no bits, just words to shift
 0000004F  62 62 FD 48/ 7C					VPBROADCASTQ	ZMM29, RAX						; Nr bits to shift right
	   E8
 00000055  62 01 9D 40/ EF					VPXORQ			ZMM28, ZMM28, ZMM28				; 
	   E4
 0000005B  62 03 85 40/ 03					VALIGNQ			ZMM30, ZMM31, ZMM28, 7			; shift copy of words left one word (to get low order bits aligned for shift)
	   F4 07
 00000062  62 02 8D 40/ 73					VPSHRDVQ		ZMM31, ZMM30, ZMM29				; shift, concatenating low bits of next word with each word to shift in
	   FD

				; with the bits shifted within the words (if needed), if the desired shift is more than 64 bits, word shifts are required
 00000068  48/ 8D 05		@@:				LEA				RAX, ShiftMaskRt	
	   0000045D R
 0000006F  66| 41/ C1 E8					SHR				R8W, 6							; divide Nr bits to shift by 64 giving Nr words to shift (can only be 0-7 based on above validation)
	   06
 00000074  4A/ 8D 04 00						LEA				RAX,  [ RAX ] [ R8 ]			; Add index to base address of mask table
 00000078  C5 F9/ 90 08						KMOVB			K1, B_PTR [ RAX ]				; create mask for words to be zeroed
 0000007C  48/ 8D 05						LEA				RAX, ShiftPermuteRt				; address of permute table
	   00000000 R
 00000083  66| 41/ C1 E0					SHL				R8W, 6							; multiply by 64 to get offset into permute table		
	   06
 00000088  4A/ 8D 04 00						LEA				RAX,  [ RAX ] [ R8 ] 			; Add offset to base address of permute table
 0000008C  62 61 FD 48/ 6F					VMOVDQA64		ZMM29, ZM_PTR [ RAX ]			; load permute indices
	   28
 00000092  62 02 95 C1/ 36					VPERMQ			ZMM31 {k1}{z}, ZMM29, ZMM31		; permute words in zmm31 to achieve word shift
	   FF
 00000098  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [ RCX ], ZMM31			; store result at callers destination
	   39
 0000009E  C3							RET

					ELSE
					ENDIF	
								Leaf_End		shr_u, ui512
 0000009F		     1	shr_u			ENDP
 0000009F		     1	ui512			ENDS


				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			shl_u		-	shift supplied source 512bit (8 QWORDS) left, put in destination
				;			Prototype:		void shl_u( u64* destination, u64* source, u16 bits_to_shift);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			bits		-	Number of bits to shift. Will fill with zeros, truncate those shifted out (in R8W)
				;			returns		-	nothing (0)

								Leaf_Entry		shl_u, ui512
 0000009F		     1	ui512			SEGMENT			PARA 'CODE'
 0000009F  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000000B0		     1	shl_u			PROC			FRAME
								CheckAlign		RCX								; (OUT) destination of shifted 8 QWORDs
								CheckAlign		RDX								; (IN)	source of 8 QWORDS

 000000B0  66| 41/ 81 F8					CMP				R8W, 512						; handle edge case, shift 512 or more bits
	   0200
 000000B6  7C 0D						JL				@F
								Zero512			RCX								; zero destination
 000000B8  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000000BE  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000000C4  C3							RET
 000000C5  49/ 81 E0		@@:				AND				R8, 511							; mask out high bits above shift count, test for 0
	   000001FF
 000000CC  75 12						JNE				@F								; handle edge case, shift zero bits
 000000CE  48/ 3B CA						CMP				RCX, RDX						; destination same as source?
 000000D1  74 0C						JE				@@r								; no copy needed
								Copy512			RCX, RDX						; no shift, just copy (destination, source already in regs)
 000000D3  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 000000D9  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000000DF  C3			@@r:			RET
 000000E0			@@:

					IF __UseZ	
 000000E0  62 61 FD 48/ 6F					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]			; load the 8 qwords into zmm reg (note: word order)
	   3A
 000000E6  49/ 8D 00						LEA				RAX, [ R8 ]
 000000E9  66| 83 E0 3F						AND				AX, 03fh
 000000ED  74 19						JZ				@F								; must be multiple of 64 bits to shift, no bits, just words to shift

				; Do the shift of bits within the 64 bit words
 000000EF  62 62 FD 48/ 7C					VPBROADCASTQ	ZMM29, RAX						; Nr bits to shift left
	   E8
 000000F5  62 01 9D 40/ EF					VPXORQ			ZMM28, ZMM28, ZMM28				; 
	   E4
 000000FB  62 03 9D 40/ 03					VALIGNQ			ZMM30, ZMM28, ZMM31, 1			; shift copy of words right one word (to get low order bits aligned for shift)
	   F7 01
 00000102  62 02 8D 40/ 71					VPSHLDVQ		ZMM31, ZMM30, ZMM29				; shift, concatenating low bits of next word with each word to shift in
	   FD

				; with the bits shifted within the words, if the desired shift is more than 64 bits, word shifts are required
 00000108  48/ 8D 05		@@:				LEA				RAX, ShiftMaskLt	
	   00000465 R
 0000010F  66| 41/ C1 E8					SHR				R8W, 6							; divide Nr bits to shift by 64 giving Nr words to shift (can only be 0-7 based on above validation)
	   06
 00000114  4A/ 8D 04 00						LEA				RAX, [ RAX ] [ R8 ]				; Add index to base address of mask table
 00000118  C5 F9/ 90 08						KMOVB			K1, B_PTR [ RAX ]				; create mask for words to be zeroed
 0000011C  48/ 8D 05						LEA				RAX, ShiftPermuteLt				; address of permute table
	   00000200 R
 00000123  66| 41/ C1 E0					SHL				R8W, 6							; multiply by 64 to get offset into permute table		
	   06
 00000128  4A/ 8D 04 00						LEA				RAX, [ RAX ] [ R8 ] 			; Add index to base address of permute table	
 0000012C  62 61 FD 48/ 6F					VMOVDQA64		ZMM29, ZM_PTR [ RAX ]			; load permute indices
	   28
 00000132  62 02 95 C1/ 36					VPERMQ			ZMM31 {k1}{z}, ZMM29, ZMM31		; permute words in zmm31 to achieve word shift
	   FF
 00000138  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [ RCX ], ZMM31			; store result at callers destination
	   39
 0000013E  C3							RET
								
					ELSE
					ENDIF
								Leaf_End		shl_u, ui512
 0000013F		     1	shl_u			ENDP
 0000013F		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			and_u		-	logical 'AND' bits in lh_op, rh_op, put result in destination
				;			Prototype:		void and_u( u64* destination, u64* lh_op, u64* rh_op);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			lh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			rh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in R8)
				;			returns		-	nothing (0)

								Leaf_Entry		and_u, ui512
 0000013F		     1	ui512			SEGMENT			PARA 'CODE'
 0000013F  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000150		     1	and_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX
								CheckAlign		R8

					IF __UseZ	
 00000150  62 61 FD 48/ 6F					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]			; load lh_op	
	   3A
 00000156  62 41 85 40/ DB					VPANDQ			ZMM31, ZMM31, ZM_PTR [ R8 ]		; 'AND' with rh_op
	   38
 0000015C  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [ RCX ], ZMM31			; store at destination address
	   39

					ELSEIF __UseY
					ENDIF
 00000162  C3							RET		
								Leaf_End		and_u, ui512
 00000163		     1	and_u			ENDP
 00000163		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			or_u		-	logical 'OR' bits in lh_op, rh_op, put result in destination
				;			Prototype:		void or_u( u64* destination, u64* lh_op, u64* rh_op);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			lh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			rh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in R8)
				;			returns		-	nothing (0)

								Leaf_Entry		or_u, ui512
 00000163		     1	ui512			SEGMENT			PARA 'CODE'
 00000163  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000170		     1	or_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX
								CheckAlign		R8

					IF __UseZ	
 00000170  62 61 FD 48/ 6F					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]			
	   3A
 00000176  62 41 85 40/ EB					VPORQ			ZMM31, ZMM31, ZM_PTR [ R8 ]
	   38
 0000017C  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39

					ELSEIF __UseY
					ENDIF
 00000182  C3							RET 
								Leaf_End		or_u, ui512
 00000183		     1	or_u			ENDP
 00000183		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			xor_u		-	logical 'XOR' bits in lh_op, rh_op, put result in destination
				;			Prototype:		void xor_u( u64* destination, u64* lh_op, u64* rh_op);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			lh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			rh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in R8)
				;			returns		-	nothing (0)

								Leaf_Entry		xor_u, ui512
 00000183		     1	ui512			SEGMENT			PARA 'CODE'
 00000183  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000190		     1	xor_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX
								CheckAlign		R8

					IF __UseZ	
 00000190  62 61 FD 48/ 6F					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]			
	   3A
 00000196  62 41 85 40/ EF					VPXORQ			ZMM31, ZMM31, ZM_PTR [ R8 ]
	   38
 0000019C  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39

					ELSEIF __UseY
					ENDIF
 000001A2  C3							RET 
								Leaf_End		xor_u, ui512
 000001A3		     1	xor_u			ENDP
 000001A3		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			not_u		-	logical 'NOT' bits in source, put result in destination
				;			Prototype:		void not_u( u64* destination, u64* source);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			returns		-	nothing (0)

								Leaf_Entry		not_u, ui512
 000001A3		     1	ui512			SEGMENT			PARA 'CODE'
 000001A3  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000001B0		     1	not_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX

					IF __UseZ	
 000001B0  62 61 FD 48/ 6F					VMOVDQA64		ZMM31, ZM_PTR [RDX]			
	   3A
 000001B6  62 61 85 40/ DF					VPANDNQ			ZMM31, ZMM31, qOnes					; qOnes (declared in the data section of this module) is 8 QWORDS, binary all ones
	   3D 00000400 R
 000001C0  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [RCX], ZMM31
	   39

					ELSEIF __UseY
					ENDIF
 000001C6  C3							RET	
								Leaf_End		not_u, ui512
 000001C7		     1	not_u			ENDP
 000001C7		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			msb_u		-	find most significant bit in supplied source 512bit (8 QWORDS)
				;			Prototype:		s16 msb_u( u64* source );
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			returns		-	-1 if no most significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
				;			Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit)
				;					a returned 511 means bit63 of the first word (the left most bit)

								Leaf_Entry		msb_u, ui512
 000001C7		     1	ui512			SEGMENT			PARA 'CODE'
 000001C7  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000001D0		     1	msb_u			PROC			FRAME
								CheckAlign		RCX								; (IN) source to scan 

					IF __UseZ
 000001D0  62 61 FD 48/ 6F					VMOVDQA64		ZMM31, ZM_PTR [RCX]				; Load source 
	   39
 000001D6  62 92 85 40/ 27					VPTESTMQ		k1, ZMM31, ZMM31				; find non-zero words (if any)
	   CF
 000001DC  C5 F9/ 93 C1						KMOVB			EAX, k1							; ZMM regs in least significant word to most ([0] lsw to [7] msw)
 000001E0  F3/ 0F BC C8						TZCNT			ECX, EAX						; determine index of word from last (trailing) non-zero bit in mask
 000001E4  73 08						JNC				@F								; all words zero?
 000001E6  8D 04 25						LEA				EAX, [ retcode_neg_one ]		; exit with -1 if all eight qwords are zero (no significant bit)
	   FFFFFFFF
 000001ED  C3							RET
 000001EE  8D 04 25		@@:				LEA				EAX, [ 7 ]						; numbering of words in Z regs (and hence in k1 mask) is reverse in significance order
	   00000007
 000001F5  2B C1						SUB				EAX, ECX						; so 7 minus leading k bit index becomes index to our ui512 bit qword
 000001F7  C1 E0 06						SHL				EAX, 6							; convert index to offset
 000001FA  62 62 FD C9/ 8B					VPCOMPRESSQ		ZMM0 {k1}{z}, ZMM31				; compress it into first word of ZMM0, which is also XMM0
	   F8
 00000200  C4 E1 F9/ 7E C1					VMOVQ			RCX, XMM0						; extract the non-zero word (k1 still has index to it)
 00000205  F3/ 48/ 0F BD C9					LZCNT			RCX, RCX						; get the index of the non-zero bit within the word
 0000020A  83 C0 3F						ADD				EAX, 63							; LZCNT counts leading non-zero bits. Subtract from 63 to get our bit index
 0000020D  2B C1						SUB				EAX, ECX						; Word index * 64 + bit index becomes bit index to first non-zero bit (0 to 511, where )
 0000020F  C3							RET

					ELSE
					ENDIF
								Leaf_End		msb_u, ui512
 00000210		     1	msb_u			ENDP
 00000210		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			lsb_u		-	find least significant bit in supplied source 512bit (8 QWORDS)
				;			Prototype:		s16 lsb_u( u64* source );
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			returns		-	-1 if no least significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
				;			Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit)
				;					a returned 511 means bit63 of the first word (the left most bit)

								Leaf_Entry		lsb_u, ui512				
 00000210		     1	ui512			SEGMENT			PARA 'CODE'
 00000210  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000220		     1	lsb_u			PROC			FRAME
								CheckAlign		RCX								; (IN) source to scan

					IF __UseZ
 00000220  62 61 FD 48/ 6F					VMOVDQA64		ZMM31, ZM_PTR [ RCX ]			; Load source 
	   39
 00000226  62 92 85 40/ 27					VPTESTMQ		k1, ZMM31, ZMM31				; find non-zero words (if any)
	   CF
 0000022C  C5 F9/ 93 C1						KMOVB			EAX, k1
 00000230  F3/ 44/ 0F BD D0					LZCNT			R10D, EAX						; ZMM regs in least significant word to most ([0] lsw to [7] msw)
 00000235  73 08						JNC				@F
 00000237  8D 04 25						LEA				EAX, [ retcode_neg_one ]		; exit with -1 if all eight qwords are zero (no significant bit)
	   FFFFFFFF
 0000023E  C3							RET
 0000023F  49/ 83 E2 07		@@:				AND				R10, 7							; mask out all but 0 -> 7
 00000243  8D 04 25						LEA				EAX, [ 7 ]						; numbering of words in Z regs (and hence in k1 mask) is reverse in significance order
	   00000007
 0000024A  41/ 2B C2						SUB				EAX, R10D						; so 7 minus leading k bit index becomes index to our ui512 bit qword
 0000024D  45/ 33 C9						XOR				R9D, R9D
 00000250  41/ FF C1						INC				R9D
 00000253  8A C8						MOV				CL, AL
 00000255  41/ D3 E1						SHL				R9D, CL
 00000258  C4 C1 79/ 92 C9					KMOVB			k1, R9D
 0000025D  62 62 FD C9/ 8B					VPCOMPRESSQ		ZMM0 {k1}{z}, ZMM31
	   F8
 00000263  C4 E1 F9/ 7E C0					VMOVQ			RAX, XMM0						; extract the non-zero word
 00000268  41/ C1 E2 06						SHL				R10D, 6							; convert index to offset
 0000026C  F3/ 48/ 0F BC C0					TZCNT			RAX, RAX						; get the index of the non-zero bit within the word
 00000271  41/ 03 C2						ADD				EAX, R10D						; Word index * 64 + bit index becomes bit index to first non-zero bit (0 to 511, where )
 00000274  C3							RET

					ELSE
					ENDIF
								Leaf_End		lsb_u, ui512
 00000275		     1	lsb_u			ENDP
 00000275		     1	ui512			ENDS

				END
Microsoft (R) Macro Assembler (x64) Version 14.44.35215.0   08/25/25 20:37:28
ui512b.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

CheckAlign . . . . . . . . . . .	Proc
Copy512Q . . . . . . . . . . . .	Proc
Copy512  . . . . . . . . . . . .	Proc
Leaf_End . . . . . . . . . . . .	Proc
Leaf_Entry . . . . . . . . . . .	Proc
MemConstants . . . . . . . . . .	Proc
ShiftOrL . . . . . . . . . . . .	Proc
ShiftOrR . . . . . . . . . . . .	Proc
VerifyRegs . . . . . . . . . . .	Proc
Zero512Q . . . . . . . . . . . .	Proc
Zero512  . . . . . . . . . . . .	Proc


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

kMask  . . . . . . . . . . . . .	 00000009      00000009
  b8 . . . . . . . . . . . . . .	 00000008      00000001	     0100     ?
  b7 . . . . . . . . . . . . . .	 00000007      00000001	     0080     ?
  b6 . . . . . . . . . . . . . .	 00000006      00000001	     0040     ?
  b5 . . . . . . . . . . . . . .	 00000005      00000001	     0020     ?
  b4 . . . . . . . . . . . . . .	 00000004      00000001	     0010     ?
  b3 . . . . . . . . . . . . . .	 00000003      00000001	     0008     ?
  b2 . . . . . . . . . . . . . .	 00000002      00000001	     0004     ?
  b1 . . . . . . . . . . . . . .	 00000001      00000001	     0002     ?
  b0 . . . . . . . . . . . . . .	 00000000      00000001	     0001     ?


Types:

                N a m e                  Size     Attr

LPVOID . . . . . . . . . . . . .	 00000008     PTR VOID


Segments:

                N a m e                  Length   Align   Class

ui512D . . . . . . . . . . . . .	 0000046D 64	  'RODATA'  
ui512  . . . . . . . . . . . . .	 00000275 16	  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

and_u  . . . . . . . . . . . . .	P 	 00000150 ui512	Length= 00000013 Public
lsb_u  . . . . . . . . . . . . .	P 	 00000220 ui512	Length= 00000055 Public
msb_u  . . . . . . . . . . . . .	P 	 000001D0 ui512	Length= 00000040 Public
not_u  . . . . . . . . . . . . .	P 	 000001B0 ui512	Length= 00000017 Public
or_u . . . . . . . . . . . . . .	P 	 00000170 ui512	Length= 00000013 Public
shl_u  . . . . . . . . . . . . .	P 	 000000B0 ui512	Length= 0000008F Public
  @@r  . . . . . . . . . . . . .	L 	 000000DF ui512	
shr_u  . . . . . . . . . . . . .	P 	 00000010 ui512	Length= 0000008F Public
  @@ret  . . . . . . . . . . . .	L 	 0000003F ui512	
xor_u  . . . . . . . . . . . . .	P 	 00000190 ui512	Length= 00000013 Public


Symbols:

                N a m e                 Type     Value    Attr

$xdatasym  . . . . . . . . . . .	Byte	 00000000 _XDATA	
B_PTR  . . . . . . . . . . . . .	Text   	 BYTE PTR
CPEQ . . . . . . . . . . . . . .	Number	 00000000h   
CPFALSE  . . . . . . . . . . . .	Number	 00000003h   
CPGE . . . . . . . . . . . . . .	Number	 00000005h   
CPGT . . . . . . . . . . . . . .	Number	 00000006h   
CPLE . . . . . . . . . . . . . .	Number	 00000002h   
CPLT . . . . . . . . . . . . . .	Number	 00000001h   
CPNE . . . . . . . . . . . . . .	Number	 00000004h   
CPTRUE . . . . . . . . . . . . .	Number	 00000007h   
D_PTR  . . . . . . . . . . . . .	Text   	 DWORD PTR
Q_PTR  . . . . . . . . . . . . .	Text   	 QWORD PTR
ShiftMaskLt  . . . . . . . . . .	Byte	 00000465 ui512D	
ShiftMaskRt  . . . . . . . . . .	Byte	 0000045D ui512D	
ShiftPermuteLt . . . . . . . . .	QWord	 00000200 ui512D	
ShiftPermuteRt . . . . . . . . .	QWord	 00000000 ui512D	
W_PTR  . . . . . . . . . . . . .	Text   	 WORD PTR
XM_PTR . . . . . . . . . . . . .	Text   	 XMMWORD PTR
YM_PTR . . . . . . . . . . . . .	Text   	 YMMWORD PTR
ZM_PTR . . . . . . . . . . . . .	Text   	 ZMMWORD PTR
__CheckAlign . . . . . . . . . .	Number	 00000000h   
__UseBMI2  . . . . . . . . . . .	Number	 00000001h   
__UseQ . . . . . . . . . . . . .	Number	 00000000h   
__UseX . . . . . . . . . . . . .	Number	 00000000h   
__UseY . . . . . . . . . . . . .	Number	 00000000h   
__UseZ . . . . . . . . . . . . .	Number	 00000001h   
__VerifyRegs . . . . . . . . . .	Number	 00000001h   
add_uT64 . . . . . . . . . . . .	L 	 00000000 External
add_u  . . . . . . . . . . . . .	L 	 00000000 External
compare_uT64 . . . . . . . . . .	L 	 00000000 External
compare_u  . . . . . . . . . . .	L 	 00000000 External
compile_time_options_INC . . . .	Text   	 1
copy_u . . . . . . . . . . . . .	L 	 00000000 External
legalnotes . . . . . . . . . . .	Number	 00000001h   
m32BCST  . . . . . . . . . . . .	Text   	 DWORD BCST
m64BCST  . . . . . . . . . . . .	Text   	 QWORD BCST
mskAll8  . . . . . . . . . . . .	Byte	 0000045C ui512D	
mskB0  . . . . . . . . . . . . .	Byte	 00000454 ui512D	
mskB1  . . . . . . . . . . . . .	Byte	 00000455 ui512D	
mskB2  . . . . . . . . . . . . .	Byte	 00000456 ui512D	
mskB3  . . . . . . . . . . . . .	Byte	 00000457 ui512D	
mskB4  . . . . . . . . . . . . .	Byte	 00000458 ui512D	
mskB5  . . . . . . . . . . . . .	Byte	 00000459 ui512D	
mskB6  . . . . . . . . . . . . .	Byte	 0000045A ui512D	
mskB7  . . . . . . . . . . . . .	Byte	 0000045B ui512D	
qOnes  . . . . . . . . . . . . .	QWord	 00000400 ui512D	
reg_verify . . . . . . . . . . .	L 	 00000000 External
ret_neg_one  . . . . . . . . . .	DWord	 00000450 ui512D	
ret_one  . . . . . . . . . . . .	DWord	 0000044C ui512D	
ret_zero . . . . . . . . . . . .	DWord	 00000448 ui512D	
retcode_neg_one  . . . . . . . .	Number	 -00000001h   
retcode_one  . . . . . . . . . .	Number	 00000001h   
retcode_zero . . . . . . . . . .	Number	 00000000h   
set_uT64 . . . . . . . . . . . .	L 	 00000000 External
sub_uT64 . . . . . . . . . . . .	L 	 00000000 External
sub_u  . . . . . . . . . . . . .	L 	 00000000 External
ui512aMacros_INC . . . . . . . .	Text   	 1
ui512bMacros_INC . . . . . . . .	Text   	 1
zeroQ  . . . . . . . . . . . . .	QWord	 00000440 ui512D	
zero_u . . . . . . . . . . . . .	L 	 00000000 External

	   0 Warnings
	   0 Errors
