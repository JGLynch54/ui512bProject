Microsoft (R) Macro Assembler (x64) Version 14.44.35214.0   08/17/25 22:33:01
ui512b.asm						     Page 1 - 1


				IFNDEF			legalnotes
 = 00000001			legalnotes		EQU				1
				;
				;			ui512b
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			File:			ui512b.asm
				;			Author:			John G. Lynch
				;			Legal:			Copyright @2024, per MIT License below
				;			Date:			June 11, 2024
				;
				;			Notes:
				;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
				;
				;				ui512a provides basic operations: zero, copy, compare, add, subtract.
				;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
				;				ui512md provides multiply and divide.
				;
				;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
				;				(currently using VS Community 2022 17.14.10)
				;
				;				It provides external signatures that allow linkage to C and C++ programs,
				;				where a shell/wrapper could encapsulate the methods as part of an object.
				;
				;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
				;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
				;
				;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
				;
				;				If processor extensions are used, the caller must align the variables declared and passed
				;				on the appropriate byte boundary (e.g. align as 64 for 512)
				;
				;				This module is very light-weight (less than 2K bytes) and relatively fast,
				;				but is not intended for all processor types or all environments. 
				;
				;				Use for private (hobbyist), or instructional, or as an example for more ambitious projects.
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;
				;			MIT License
				;
				;			Copyright (c) 2024 John G. Lynch
				;
				;				Permission is hereby granted, free of charge, to any person obtaining a copy
				;				of this software and associated documentation files (the "Software"), to deal
				;				in the Software without restriction, including without limitation the rights
				;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				;				copies of the Software, and to permit persons to whom the Software is
				;				furnished to do so, subject to the following conditions:
				;
				;				The above copyright notice and this permission notice shall be included in all
				;				copies or substantial portions of the Software.
				;
				;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
				;				SOFTWARE.
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				ENDIF			; legal notes

								INCLUDE			compile_time_options.inc
			      C IFNDEF		legalnotes
			      C ENDIF			; legalnotes
			      C 
			      C IFNDEF							compile_time_options_INC
 = 1			      C compile_time_options_INC		EQU			<1>
			      C 
			      C ;			Configuration choices
 = 00000000		      C __UseZ			EQU				0									; Use AVX4 processor features (512 bit registers and instructions)
 = 00000000		      C __UseY			EQU				0									; Use AVX2 processor features (256 bit registers and instructions)
 = 00000000		      C __UseX			EQU				0									; Use SIMD/SSE processor features (128 bit registers and instructions)
 = 00000001		      C __UseQ			EQU				1									; Do not use extensions, use standard x64 bit registers and instructions
			      C ;
 = 00000001		      C __UseBMI2		EQU				1									; Bit manipulation instructions (Haswell and later) ref:https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set
			      C ;
 = 00000001		      C __VerifyRegs	EQU				1									; in debug mode, or with unit tests, define routine to verify non-volatile regs 
 = 00000000		      C __CheckAlign	EQU				0									; User is expected to pass arguments aligned on 64 byte boundaries, 
			      C ;																	; This setting enforces that with a check. It should not be necessary, but included to help debugging
			      C 
			      C ENDIF			; compile_time_options_INC
			      C 
								INCLUDE			ui512aMacros.inc
			      C IFNDEF		legalnotes
			      C ENDIF			; legalnotes
			      C 
			      C IFNDEF			ui512aMacros_INC
 = 1			      C ui512aMacros_INC EQU			<1>
			      C 
			      C 
			      C ;           header file equivalent extern declarations
			      C ;			EXTERN "C" signatures (from ui512a.asm)
			      C 
			      C ;	// void zero_u ( u64* destarr ); 
			      C ;	// fill supplied 512bit (8 QWORDS) with zero
			      C EXTERNDEF		zero_u:PROC
			      C 
			      C 
			      C ;	// void copy_u ( u64* destarr, u64* srcarr );
			      C ;	// copy supplied 512bit (8 QWORDS) source to supplied destination
			      C EXTERNDEF		copy_u:PROC
			      C 
			      C ;	// void set_uT64 ( u64* destarr, u64 value );
			      C ;	// set supplied destination 512 bit to supplied u64 value
			      C EXTERNDEF		set_uT64:PROC
			      C 
			      C ;	// s16 compare_u ( u64* lh_op, u64* rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_u:PROC
			      C 
			      C ;	// s16 compare_uT64 ( u64* lh_op, u64 rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand (value)
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_uT64:PROC
			      C 
			      C ;	// s16 add_u ( u64* sum, u64* addend1, u64* addend2 );
			      C ;	// add supplied 512bit (8 QWORDS) sources, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u:PROC
			      C 
			      C ;	// s16 add_uT64 ( u64* sum, u64* addend1, u64 addend2 );
			      C ;	// add 64bit QWORD (value) to supplied 512bit (8 QWORDS), place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_uT64:PROC
			      C 
			      C ;	// s16 sub_u ( u64* difference, u64* left operand, u64* right operand );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u:PROC
			      C 
			      C ;	// s16 sub_uT64( u64* difference, u64* left operand, u64 right operand );
			      C ;	// subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_uT64:PROC
			      C ;
			      C 
			      C ;           Some coding shortcuts
 = ZMMWORD PTR		      C ZM_PTR			EQU				ZMMWORD PTR 
 = YMMWORD PTR		      C YM_PTR			EQU				YMMWORD PTR
 = XMMWORD PTR		      C XM_PTR			EQU				XMMWORD PTR
 = QWORD PTR		      C Q_PTR			EQU				QWORD PTR
 = DWORD PTR		      C D_PTR			EQU				DWORD PTR
 = WORD PTR		      C W_PTR			EQU				WORD PTR
 = BYTE PTR		      C B_PTR			EQU				BYTE PTR
 = DWORD BCST		      C m32BCST			EQU				DWORD BCST
 = QWORD BCST		      C m64BCST			EQU				QWORD BCST
			      C LPVOID			TYPEDEF			PTR VOID
			      C ;			mask codes (for compares using instructions like VPCMPUQ)
 = 00000000		      C CPEQ			EQU				0
 = 00000001		      C CPLT			EQU				1
 = 00000002		      C CPLE			EQU				2
 = 00000003		      C CPFALSE			EQU				3
 = 00000004		      C CPNE			EQU				4
 = 00000005		      C CPGE			EQU				5
 = 00000006		      C CPGT			EQU				6
 = 00000007		      C CPTRUE			EQU				7
			      C 
			      C ;
			      C ; MemConstants <none>
			      C ;
			      C ;		Define useful constants
			      C ;		Note: this must be first in a data segment aligned (64)
			      C ;
			      C MemConstants	MACRO
			      C ; 
			      C qOnes			QWORD           8 DUP (0ffffffffffffffffh)
			      C zeroQ			DQ				0
			      C 
			      C ;		Return codes commonly used.	
			      C retcode_zero	EQU				0
			      C retcode_one		EQU				1
			      C retcode_neg_one	EQU				-1
			      C ;		Sometimes need to get it from memory, not an immediate value. So:
			      C ret_zero		DD				retcode_zero						
			      C ret_one			DD				retcode_one
			      C ret_neg_one		DD				retcode_neg_one
			      C 
			      C ;		Masks commonly used
			      C ;		Record form, whic can be used as immediate values
			      C kMask			RECORD			b8:1, b7:1, b6:1, b5:1, b4:1, b3:1, b2:1, b1:1, b0:1
			      C ;		And as memory, for when immediate simply wont do
			      C mskB0			DB				1
			      C mskB1			DB				2
			      C mskB2			DB				4
			      C mskB3			DB				8
			      C mskB4			DB				16
			      C mskB5			DB				32
			      C mskB6			DB				64
			      C mskB7			DB				128
			      C mskAll8			DB				255
			      C 				ENDM
			      C 
			      C ;==================================================================================================
			      C ;           Notes on x64 calling conventions        specifically "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The callers first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address
			      C ; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ; return (if any) is in EAX
			      C ;
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile,
			      C ;	and do not need to be saved
			      C ;  ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C ;==================================================================================================
			      C 
			      C ;==================================================================================================
			      C ; Selected macros from "macamd64.inc" (c) Microsoft Corporation
			      C ;	These macros generate .xdata and .pdata entries in the executable image file.
			      C ;	The entries assist in exception and debugging; helping 'unwind' operations.
			      C ;	Only a few macros are included, and are reformatted to match coding style:
			      C ;	indents and capitalization.
			      C ;
			      C ; LEAF_ENTRY <Name>, <Section>
			      C ;
			      C ; Macro Description:
			      C ;
			      C ;   This macro indicates the beginning of a leaf function.
			      C ;
			      C ;   A leaf function is one that DOES NOT:
			      C ;
			      C ;   - manipulate non-volatile registers
			      C ;   - manipulate the stack pointer
			      C ;   - call other functions
			      C ;   - reference an exception handler
			      C ;   - contain a prologue
			      C ;   - have any unwind data associated with it
			      C ;
			      C ; Arguments:
			      C ;
			      C ;   Name - Supplies the name of the function
			      C ;
			      C ;   Section - Supplies the name of the section within which the function
			      C ;             is to appear
			      C ;
			      C Leaf_Entry		MACRO			Name, Section
			      C Section			SEGMENT			PARA 'CODE'
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				PUBLIC			Name
			      C Name			PROC			FRAME
			      C 				.ENDPROLOG
			      C 				ENDM
			      C 
			      C ;
			      C ; LEAF_END <Name>, <Section>
			      C ;
			      C ; Macro Description:
			      C ;
			      C ;   This macro indicates the end of a leaf function.  It must be paired
			      C ;   with a LEAF_ENTRY macro that includes matching Name and Section
			      C ;   parameters.
			      C ;
			      C ; Arguments:
			      C ;
			      C ;   Name - Supplies the name of the function.  Must match that supplied to
			      C ;          the corresponding LEAF_ENTRY macro.
			      C ;
			      C ;   Section - Supplies the name of the section within which the function
			      C ;             is to appear.  Must match that supplied to the corresponding
			      C ;             LEAF_ENTRY macro.
			      C ;
			      C Leaf_End		MACRO			Name, Section
			      C Name			ENDP
			      C Section			ENDS
			      C 				ENDM
			      C 
			      C ;===========================================================================================
			      C ;          Local macros
			      C ;===========================================================================================
			      C 
			      C ;
			      C ; CheckAlign <RAddr>
			      C ;
			      C ;			Test passed variable addresses for 64 byte alignment
			      C ;			Note: Better performance if this is off, but for debugging, maybe have it on
			      C ;
			      C 
			      C CheckAlign		MACRO			Raddr
			      C 				LOCAL			ok
			      C 	IF	__CheckAlign
			      C 				TEST			Raddr, 63							; Is specified param aligned 64?
			      C 				JZ				ok									; Yes, passes test, continue
			      C 				INT				13									; No? fails, break (can substitute other exception handling)
			      C ok:
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ; VerifyRegs <none>
			      C ;
			      C ;			If option is on, generate a function, callable by unit test routines, 
			      C ;				to save non-volatile registers in passed structure.
			      C ;
			      C IF	__VerifyRegs
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* regstruct)
			      C ;			reg_verify		-	copy non-volatile regs into callers struct of nine qwords) intended for unit tests to verify non-volatile regs are not changed
			      C ;			Prototype:		-	void reg_verify( uu64* regstruct);
			      C ;			regstruct		-	Address of 9 QWORDS in a struct where regs will be copied (in RCX)
			      C ; //			reg_verify		-	save non-volatile regs for verification (debug)
			      C ; //			Prototype		-	void reg_verify ( u64* reg struct)
			      C EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* reg struct)
			      C 
			      C VerifyRegs		MACRO
			      C 				Leaf_Entry		reg_verify, ui512
			      C 				MOV				Q_PTR [ RCX ] [ 0 * 8 ], R12
			      C 				MOV				Q_PTR [ RCX ] [ 1 * 8 ], R13
			      C 				MOV				Q_PTR [ RCX ] [ 2 * 8 ], R14
			      C 				MOV				Q_PTR [ RCX ] [ 3 * 8 ], R15
			      C 				MOV				Q_PTR [ RCX ] [ 4 * 8 ], RDI
			      C 				MOV				Q_PTR [ RCX ] [ 5 * 8 ], RSI
			      C 				MOV				Q_PTR [ RCX ] [ 6 * 8 ], RBX
			      C 				MOV				Q_PTR [ RCX ] [ 7 * 8 ], RBP
			      C 				MOV				Q_PTR [ RCX ] [ 8 * 8 ], RSP
			      C 				RET
			      C 				Leaf_End		reg_verify, ui512
			      C 				ENDM
			      C ENDIF
			      C 
			      C ;
			      C ;			Zero a 512 bit destination, conditional assembly based on configuration parameters
			      C ;
			      C Zero512			MACRO			dest:REQ
			      C 	IF		__UseZ
			      C 				CheckAlign		dest
			      C 				VPXORQ			ZMM31, ZMM31, ZMM31
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				VPXORQ			YMM4, YMM4, YMM4
			      C 				FOR				idx, < 0, 4 >
			      C 				VMOVDQA64		YM_PTR [ dest ] [ idx * 8 ], YMM4
			      C 				ENDM
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				PXOR			XMM4, XMM4
			      C 				FOR				idx, < 0, 2, 4, 6 >
			      C 				MOVDQA			XM_PTR [ dest ] [ idx * 8 ], XMM4
			      C 				ENDM		
			      C 	ELSE
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ;			Zero a 512 bit destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Zero512Q		MACRO			dest:REQ
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ;
			      C ;			Copy a 512 bit source to destination, conditional assembly based on configuration parameters
			      C ;
			      C Copy512			MACRO			dest:REQ, src:REQ
			      C 	IF		__UseZ 
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		ZMM31, ZM_PTR [ src ]
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		YMM4, YM_PTR [ src + 0 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			      C 				VMOVDQA64		YMM5, YM_PTR [ src ] [ 4 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 4 * 8 ], YMM5
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 0 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 0 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 2 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 2 * 8 ], XMM3
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 4 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 4 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 6 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 6 * 8 ], XMM3
			      C 	ELSE
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ;			Copy a 512 bit source to destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Copy512Q		MACRO			dest:REQ, src:REQ
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ENDIF	; IFNDEF			ui512aMacros_INC
			      C 
								INCLUDE			ui512bMacros.inc
			      C IFNDEF			legalnotes
			      C ENDIF			; legal notes	
			      C 
			      C IFNDEF			ui512bMacros_INC
 = 1			      C ui512bMacros_INC EQU		<1>
			      C 
			      C ;           header file equivalent extern declarations
			      C ;			EXTERN "C" signatures (from ui512b.asm)
			      C 
			      C ;   // void shr_u ( u64* destination, u64* source, u16 bits_to_shift )
			      C ;   // shift supplied source 512bit (8 QWORDS) right, put in destination
			      C EXTERNDEF		shr_u:PROC
			      C 
			      C ;   // void shl_u ( u64* destination, u64* source, u16 bits_to_shift );
			      C ;   // shift supplied source 512bit (8 QWORDS) left, put in destination
			      C EXTERNDEF		shl_u:PROC
			      C 
			      C ;   // void and_u ( u64* destination, u64* lh_op, u64* rh_op );
			      C ;   // logical 'AND' bits in lh_op, rh_op, put result in destination
			      C EXTERNDEF		and_u:PROC
			      C 
			      C ;   // logical 'OR' bits in lh_op, rh_op, put result in destination
			      C ;   // void or_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		or_u:PROC
			      C 
			      C ;   // logical 'XOR' bits in lh_op, rh_op, put result in destination
			      C ;   // void xor_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		xor_u:PROC
			      C 
			      C ;   // logical 'NOT' bits in source, put result in destination
			      C ;	// void not_u( u64* destination, u64* source);
			      C EXTERNDEF		not_u:PROC
			      C 
			      C ;   // find most significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 msb_u( u64* );
			      C ;   // returns: -1 if no most significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit)
			      C ;	//			a returned 511 means bit63 of the first word(the left most bit);	//	a returned 511 means bit63 of the first word
			      C EXTERNDEF		msb_u:PROC
			      C 
			      C ;   // find least significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 lsb_u( u64* );
			      C ;   // returns: -1 if no least significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit)
			      C ;	//			a returned 511 means bit63 of the first word(the left most bit);	//	a returned 511 means bit63 of the first word
			      C EXTERNDEF		lsb_u:PROC
			      C 
			      C ENDIF			; ui512bMacros_INC
			      C 
								OPTION			casemap:none

 00000000			ui512D			SEGMENT			'DATA'	ALIGN (64)				; Declare a data segment. Aligned 64.	
								MemConstants									; Generate memory resident constants
 00000000  00000008 [	     1	qOnes			QWORD           8 DUP (0ffffffffffffffffh)
	    FFFFFFFFFFFFFFFF
	   ]
 00000040		     1	zeroQ			DQ				0
	   0000000000000000
 = 00000000		     1	retcode_zero	EQU				0
 = 00000001		     1	retcode_one		EQU				1
 =-00000001		     1	retcode_neg_one	EQU				-1
 00000048 00000000	     1	ret_zero		DD				retcode_zero						
 0000004C 00000001	     1	ret_one			DD				retcode_one
 00000050 FFFFFFFF	     1	ret_neg_one		DD				retcode_neg_one
 00000054 01		     1	mskB0			DB				1
 00000055 02		     1	mskB1			DB				2
 00000056 04		     1	mskB2			DB				4
 00000057 08		     1	mskB3			DB				8
 00000058 10		     1	mskB4			DB				16
 00000059 20		     1	mskB5			DB				32
 0000005A 40		     1	mskB6			DB				64
 0000005B 80		     1	mskB7			DB				128
 0000005C FF		     1	mskAll8			DB				255
 0000005D			ui512D			ENDS											; end of data segment


				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			shr_u		-	shift supplied source 512bit (8 QWORDS) right, put in destination
				;			Prototype:		void shr_u( u64* destination, u64* source, u32 bits_to_shift)
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			bits		-	Number of bits to shift. Will fill with zeros, truncate those shifted out (in R8W)
				;			returns		-	nothing (0)
				;			Note: unwound loop(s). More instructions, but fewer executed (no loop save, setup, compare loop), faster, fewer regs used

								Leaf_Entry		shr_u, ui512
 00000000		     1	ui512			SEGMENT			PARA 'CODE'
 00000000  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000010		     1	shr_u			PROC			FRAME
								CheckAlign		RCX								; (OUT) destination of shifted 8 QWORDs
								CheckAlign		RDX								; (IN)	source of 8 QWORDS

 00000010  66| 41/ 81 F8					CMP				R8W, 512						; handle edge case, shift 512 or more bits
	   0200
 00000016  7C 23						JL				@F
								Zero512			RCX								; zero destination
 00000018  48/ 33 C0	     1					XOR				RAX, RAX
 0000001B  48/ 89 01	     2					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 0000001E  48/ 89 41 08	     2					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 00000022  48/ 89 41 10	     2					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 00000026  48/ 89 41 18	     2					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 0000002A  48/ 89 41 20	     2					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 0000002E  48/ 89 41 28	     2					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 00000032  48/ 89 41 30	     2					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 00000036  48/ 89 41 38	     2					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX
 0000003A  C3							RET
 0000003B			@@:
 0000003B  49/ 81 E0						AND				R8, 511							; ensure no high bits above shift count
	   000001FF
 00000042  75 44						JNZ				@F								; handle edge case, zero bits to shift
 00000044  48/ 3B CA						CMP				RCX, RDX
 00000047  74 3E						JE				@@ret							; destination is the same as the source: no copy needed
								Copy512			RCX, RDX						; no shift, just copy (destination, source already in regs)
 00000049  48/ 8B 02	     2					MOV				RAX, Q_PTR [ RDX ] [ 0 * 8 ]
 0000004C  48/ 89 01	     2					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 0000004F  48/ 8B 42 08	     2					MOV				RAX, Q_PTR [ RDX ] [ 1 * 8 ]
 00000053  48/ 89 41 08	     2					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 00000057  48/ 8B 42 10	     2					MOV				RAX, Q_PTR [ RDX ] [ 2 * 8 ]
 0000005B  48/ 89 41 10	     2					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 0000005F  48/ 8B 42 18	     2					MOV				RAX, Q_PTR [ RDX ] [ 3 * 8 ]
 00000063  48/ 89 41 18	     2					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 00000067  48/ 8B 42 20	     2					MOV				RAX, Q_PTR [ RDX ] [ 4 * 8 ]
 0000006B  48/ 89 41 20	     2					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 0000006F  48/ 8B 42 28	     2					MOV				RAX, Q_PTR [ RDX ] [ 5 * 8 ]
 00000073  48/ 89 41 28	     2					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 00000077  48/ 8B 42 30	     2					MOV				RAX, Q_PTR [ RDX ] [ 6 * 8 ]
 0000007B  48/ 89 41 30	     2					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 0000007F  48/ 8B 42 38	     2					MOV				RAX, Q_PTR [ RDX ] [ 7 * 8 ]
 00000083  48/ 89 41 38	     2					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX
 00000087			@@ret:
 00000087  C3							RET
 00000088			@@:

					IF	__UseZ
					ELSE

				;	save non-volatile regs to be used as work regs			
 00000088  41/ 54						PUSH			R12								; going to use 8 gp regs for the 8 qword source
 0000008A  41/ 55						PUSH			R13								; R9, R10, R11 are considered 'volatile' and dont need to be saved
 0000008C  41/ 56						PUSH			R14								; R12, R13, R14, R15, RDI must be returned to caller with current values. Save them
 0000008E  41/ 57						PUSH			R15
 00000090  57							PUSH			RDI
 00000091  51							PUSH			RCX								; need current value of RCX (dest), but also need to use the reg. Save it
 00000092  53							PUSH			RBX								; non-volatile, need the reg, so save the value

				;	load sequential regs with source 8 qwords
 00000093  4C/ 8B 0A						MOV				R9, Q_PTR [ RDX ] [ 0 * 8 ]		; R9 holds source at index [0], most significant qword
 00000096  4C/ 8B 52 08						MOV				R10, Q_PTR [ RDX ] [ 1 * 8 ]	; R10 <- [1]
 0000009A  4C/ 8B 5A 10						MOV				R11, Q_PTR [ RDX ] [ 2 * 8 ]	; R11 <- [2]
 0000009E  4C/ 8B 62 18						MOV				R12, Q_PTR [ RDX ] [ 3 * 8 ]	; R12 <- [3]
 000000A2  4C/ 8B 6A 20						MOV				R13, Q_PTR [ RDX ] [ 4 * 8 ]	; R13 <- [4]
 000000A6  4C/ 8B 72 28						MOV				R14, Q_PTR [ RDX ] [ 5 * 8 ]	; R14 <- [5]
 000000AA  4C/ 8B 7A 30						MOV				R15, Q_PTR [ RDX ] [ 6 * 8 ]	; R15 <- [6]
 000000AE  48/ 8B 7A 38						MOV				RDI, Q_PTR [ RDX ] [ 7 * 8 ]	; RDI holds source at index [7], least significant qword

				;	determine if / how many bits to shift

 000000B2  49/ 8D 08						LEA				RCX, [ R8 ]						; R8 still carries users shift count.
 000000B5  48/ 83 E1 3F						AND				RCX, 03Fh						; Mask down to Nr of bits to shift right -> RCX
 000000B9  74 6B						JZ				@@nobits						; might be word shifts, but no bit shifts required
 000000BB  48/ 8D 1C 25						LEA				RBX, [ 64 ]
	   00000040
 000000C3  48/ 2B D9						SUB				RBX, RCX						; Nr to shift left -> RBX
				;
				;	Each word is shifted right, and the bits shifted out are ORd into the next (less significant) word.
				;	RCX holds the number of bits to shift right, RBX holds the 64 bit complement for left shift.
				;

				ShiftOrR		MACRO			lReg, rReg
								SHLX			RDX, lReg, RBX					; shift 'bottom' bits to top
								SHRX			rReg, rReg, RCX					; shift target bits right (leaving zero filled bits at top)
								OR				rReg, RDX						; OR in new 'top' bits
								ENDM
				; Macro for repetitive ops. Reduces chance of typo, easier to maintain, but not used anywhere else
								ShiftOrR		R15, RDI						; RDI is target to shift, but need bits from R15 to fill in high bits
 000000C6  C4 C2 E1/ F7 D7   1					SHLX			RDX, R15, RBX					; shift 'bottom' bits to top
 000000CB  C4 E2 F3/ F7 FF   1					SHRX			RDI, RDI, RCX					; shift target bits right (leaving zero filled bits at top)
 000000D0  48/ 0B FA	     1					OR				RDI, RDX						; OR in new 'top' bits
								ShiftOrR		R14, R15						; now R15 is target, but need bits from R14
 000000D3  C4 C2 E1/ F7 D6   1					SHLX			RDX, R14, RBX					; shift 'bottom' bits to top
 000000D8  C4 42 F3/ F7 FF   1					SHRX			R15, R15, RCX					; shift target bits right (leaving zero filled bits at top)
 000000DD  4C/ 0B FA	     1					OR				R15, RDX						; OR in new 'top' bits
								ShiftOrR		R13, R14						; and on ...
 000000E0  C4 C2 E1/ F7 D5   1					SHLX			RDX, R13, RBX					; shift 'bottom' bits to top
 000000E5  C4 42 F3/ F7 F6   1					SHRX			R14, R14, RCX					; shift target bits right (leaving zero filled bits at top)
 000000EA  4C/ 0B F2	     1					OR				R14, RDX						; OR in new 'top' bits
								ShiftOrR		R12, R13
 000000ED  C4 C2 E1/ F7 D4   1					SHLX			RDX, R12, RBX					; shift 'bottom' bits to top
 000000F2  C4 42 F3/ F7 ED   1					SHRX			R13, R13, RCX					; shift target bits right (leaving zero filled bits at top)
 000000F7  4C/ 0B EA	     1					OR				R13, RDX						; OR in new 'top' bits
								ShiftOrR		R11, R12
 000000FA  C4 C2 E1/ F7 D3   1					SHLX			RDX, R11, RBX					; shift 'bottom' bits to top
 000000FF  C4 42 F3/ F7 E4   1					SHRX			R12, R12, RCX					; shift target bits right (leaving zero filled bits at top)
 00000104  4C/ 0B E2	     1					OR				R12, RDX						; OR in new 'top' bits
								ShiftOrR		R10, R11
 00000107  C4 C2 E1/ F7 D2   1					SHLX			RDX, R10, RBX					; shift 'bottom' bits to top
 0000010C  C4 42 F3/ F7 DB   1					SHRX			R11, R11, RCX					; shift target bits right (leaving zero filled bits at top)
 00000111  4C/ 0B DA	     1					OR				R11, RDX						; OR in new 'top' bits
								ShiftOrR		R9, R10				
 00000114  C4 C2 E1/ F7 D1   1					SHLX			RDX, R9, RBX					; shift 'bottom' bits to top
 00000119  C4 42 F3/ F7 D2   1					SHRX			R10, R10, RCX					; shift target bits right (leaving zero filled bits at top)
 0000011E  4C/ 0B D2	     1					OR				R10, RDX						; OR in new 'top' bits
 00000121  C4 42 F3/ F7 C9					SHRX			R9, R9, RCX						; no bits to OR in on the index 0 (high order) word, just shift it.
 00000126			@@nobits:
								; with the bits shifted within the words, if the desired shift is more than 64 bits, word shifts are required
								; verify Nr of word shift is zero to seven, use it as index into jump table; jump to appropriate shift
 00000126  66| 41/ C1 E8					SHR				R8W, 6							; divide bit shift count by 64 to get Nr words to shift
	   06
 0000012B  49/ 83 E0 07						AND				R8, 7							; mask out anything above seven (shouldnt happen, but . . . jump table, be sure)
 0000012F  66| 41/ C1 E0					SHL				R8W, 3							; multiply by 8 to get offset into jump table
	   03
 00000134  48/ 8D 05						LEA				RAX, jtbl						; base address of jump table
	   00000146 R
 0000013B  4C/ 03 C0						ADD				R8, RAX							; add to offset
 0000013E  48/ 33 C0						XOR				RAX, RAX						; clear rax for use in zeroing words shifted "in"
 00000141  5B							POP				RBX
 00000142  59							POP				RCX								; restore RBX, RCX
 00000143  41/ FF 20						JMP				Q_PTR [ R8 ]
 00000146			jtbl:
 00000146  0000000000000186 R					QWORD			S0, S1, S2, S3, S4, S5, S6, S7
	   00000000000001AA R
	   00000000000001CE R
	   00000000000001F2 R
	   0000000000000216 R
	   0000000000000237 R
	   0000000000000258 R
	   0000000000000279 R
 00000186			S0:				; no word shift, just bits, so store words in destination in the same order as they are
 00000186  4C/ 89 09						MOV				Q_PTR [ RCX ] [ 0 * 8 ], R9
 00000189  4C/ 89 51 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], R10
 0000018D  4C/ 89 59 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], R11
 00000191  4C/ 89 61 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], R12
 00000195  4C/ 89 69 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], R13
 00000199  4C/ 89 71 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], R14
 0000019D  4C/ 89 79 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], R15
 000001A1  48/ 89 79 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], RDI	
 000001A5  E9 000000EE						JMP				@@R
 000001AA			S1:
 000001AA  48/ 89 01						MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 000001AD  4C/ 89 49 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], R9
 000001B1  4C/ 89 51 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], R10
 000001B5  4C/ 89 59 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], R11
 000001B9  4C/ 89 61 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], R12
 000001BD  4C/ 89 69 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], R13
 000001C1  4C/ 89 71 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], R14
 000001C5  4C/ 89 79 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], R15	
 000001C9  E9 000000CA						JMP				@@R
 000001CE			S2:
 000001CE  48/ 89 01						MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 000001D1  48/ 89 41 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 000001D5  4C/ 89 49 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], R9
 000001D9  4C/ 89 51 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], R10
 000001DD  4C/ 89 59 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], R11
 000001E1  4C/ 89 61 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], R12
 000001E5  4C/ 89 69 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], R13
 000001E9  4C/ 89 71 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], R14	
 000001ED  E9 000000A6						JMP				@@R

 000001F2  48/ 89 01		S3:				MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 000001F5  48/ 89 41 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 000001F9  48/ 89 41 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 000001FD  4C/ 89 49 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], R9
 00000201  4C/ 89 51 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], R10
 00000205  4C/ 89 59 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], R11
 00000209  4C/ 89 61 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], R12
 0000020D  4C/ 89 69 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], R13	
 00000211  E9 00000082						JMP				@@R

 00000216  48/ 89 01		S4:				MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 00000219  48/ 89 41 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 0000021D  48/ 89 41 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 00000221  48/ 89 41 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 00000225  4C/ 89 49 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], R9
 00000229  4C/ 89 51 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], R10
 0000022D  4C/ 89 59 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], R11
 00000231  4C/ 89 61 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], R12			
 00000235  EB 61						JMP				@@R

 00000237  48/ 89 01		S5:				MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 0000023A  48/ 89 41 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 0000023E  48/ 89 41 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 00000242  48/ 89 41 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 00000246  48/ 89 41 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 0000024A  4C/ 89 49 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], R9
 0000024E  4C/ 89 51 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], R10
 00000252  4C/ 89 59 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], R11	
 00000256  EB 40						JMP				@@R

 00000258  48/ 89 01		S6:				MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 0000025B  48/ 89 41 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 0000025F  48/ 89 41 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 00000263  48/ 89 41 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 00000267  48/ 89 41 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 0000026B  48/ 89 41 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 0000026F  4C/ 89 49 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], R9
 00000273  4C/ 89 51 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], R10	
 00000277  EB 1F						JMP				@@R

 00000279  48/ 89 01		S7:				MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 0000027C  48/ 89 41 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 00000280  48/ 89 41 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 00000284  48/ 89 41 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 00000288  48/ 89 41 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 0000028C  48/ 89 41 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 00000290  48/ 89 41 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 00000294  4C/ 89 49 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], R9		
 00000298			@@R:
				;	restore non-volatile regs to as-called condition
 00000298  5F							POP				RDI
 00000299  41/ 5F						POP				R15
 0000029B  41/ 5E						POP				R14
 0000029D  41/ 5D						POP				R13
 0000029F  41/ 5C						POP				R12
 000002A1  C3							RET
					ENDIF	
								Leaf_End		shr_u, ui512
 000002A2		     1	shr_u			ENDP
 000002A2		     1	ui512			ENDS


				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			shl_u		-	shift supplied source 512bit (8 QWORDS) left, put in destination
				;			Prototype:		void shl_u( u64* destination, u64* source, u16 bits_to_shift);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			bits		-	Number of bits to shift. Will fill with zeros, truncate those shifted out (in R8W)
				;			returns		-	nothing (0)

								Leaf_Entry		shl_u, ui512
 000002A2		     1	ui512			SEGMENT			PARA 'CODE'
 000002A2  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000002B0		     1	shl_u			PROC			FRAME
								CheckAlign		RCX								; (OUT) destination of shifted 8 QWORDs
								CheckAlign		RDX								; (IN)	source of 8 QWORDS

 000002B0  66| 41/ 81 F8					CMP				R8W, 512						; handle edge case, shift 512 or more bits
	   0200
 000002B6  7C 23						JL				@F
								Zero512			RCX								; zero destination
 000002B8  48/ 33 C0	     1					XOR				RAX, RAX
 000002BB  48/ 89 01	     2					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 000002BE  48/ 89 41 08	     2					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 000002C2  48/ 89 41 10	     2					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 000002C6  48/ 89 41 18	     2					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 000002CA  48/ 89 41 20	     2					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 000002CE  48/ 89 41 28	     2					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 000002D2  48/ 89 41 30	     2					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 000002D6  48/ 89 41 38	     2					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX
 000002DA  C3							RET
 000002DB			@@:
 000002DB  49/ 81 E0						AND				R8, 511							; mask out high bits above shift count, test for 0
	   000001FF
 000002E2  75 44						JNE				@F								; handle edge case, shift zero bits
 000002E4  48/ 3B CA						CMP				RCX, RDX
 000002E7  74 3E						JE				@@r
								Copy512			RCX, RDX						; no shift, just copy (destination, source already in regs)
 000002E9  48/ 8B 02	     2					MOV				RAX, Q_PTR [ RDX ] [ 0 * 8 ]
 000002EC  48/ 89 01	     2					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 000002EF  48/ 8B 42 08	     2					MOV				RAX, Q_PTR [ RDX ] [ 1 * 8 ]
 000002F3  48/ 89 41 08	     2					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 000002F7  48/ 8B 42 10	     2					MOV				RAX, Q_PTR [ RDX ] [ 2 * 8 ]
 000002FB  48/ 89 41 10	     2					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 000002FF  48/ 8B 42 18	     2					MOV				RAX, Q_PTR [ RDX ] [ 3 * 8 ]
 00000303  48/ 89 41 18	     2					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 00000307  48/ 8B 42 20	     2					MOV				RAX, Q_PTR [ RDX ] [ 4 * 8 ]
 0000030B  48/ 89 41 20	     2					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 0000030F  48/ 8B 42 28	     2					MOV				RAX, Q_PTR [ RDX ] [ 5 * 8 ]
 00000313  48/ 89 41 28	     2					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 00000317  48/ 8B 42 30	     2					MOV				RAX, Q_PTR [ RDX ] [ 6 * 8 ]
 0000031B  48/ 89 41 30	     2					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 0000031F  48/ 8B 42 38	     2					MOV				RAX, Q_PTR [ RDX ] [ 7 * 8 ]
 00000323  48/ 89 41 38	     2					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX
 00000327			@@r:
 00000327  C3							RET
 00000328			@@:

					IF __UseZ	
					ELSE
				;	save non-volitile regs to be used as work regs			
 00000328  41/ 54						PUSH			R12
 0000032A  41/ 55						PUSH			R13
 0000032C  41/ 56						PUSH			R14
 0000032E  41/ 57						PUSH			R15
 00000330  57							PUSH			RDI
 00000331  51							PUSH			RCX
				;	load sequential regs with source 8 qwords
 00000332  4C/ 8B 0A						MOV				R9, Q_PTR [ RDX ] [ 0 * 8 ]
 00000335  4C/ 8B 52 08						MOV				R10, Q_PTR [ RDX ] [ 1 * 8 ]
 00000339  4C/ 8B 5A 10						MOV				R11, Q_PTR [ RDX ] [ 2 * 8 ]
 0000033D  4C/ 8B 62 18						MOV				R12, Q_PTR [ RDX ] [ 3 * 8 ]
 00000341  4C/ 8B 6A 20						MOV				R13, Q_PTR [ RDX ] [ 4 * 8 ]
 00000345  4C/ 8B 72 28						MOV				R14, Q_PTR [ RDX ] [ 5 * 8 ]
 00000349  4C/ 8B 7A 30						MOV				R15, Q_PTR [ RDX ] [ 6 * 8 ]
 0000034D  48/ 8B 7A 38						MOV				RDI, Q_PTR [ RDX ] [ 7 * 8 ]
				;	determine if / how many bits to shift
 00000351  49/ 8D 08						LEA 			RCX, [ R8 ]
 00000354  66| 83 E1 3F						AND				CX, 03fh
 00000358  0F 84 00000088					JZ				@@nobits
 0000035E  66| 8D 04 25						LEA				AX, [ 64 ]
	   00000040
 00000366  66| 2B C1						SUB				AX, CX
 00000369  8A C8						MOV				CL, AL							; CL right shift Nr
 0000036B  86 CD						XCHG			CL, CH
 0000036D  41/ 8A C8						MOV				CL, R8B							; CH left shift Nr
 00000370  80 E1 3F						AND				CL, 03fh
 00000373  86 CD						XCHG			CL, CH
				;
				;	Each word is shifted right, and the bits falling out are ORd into the next word.
				;	CL holds the number of bits to shift right, CH holds the complement for left shift.
				;	The CL register is used for the bit shift number, it is "XCHG" swapped with CH for the left or right shift
				;
 00000375  49/ 8B D2						MOV				RDX, R10						; Get the first word (of 0 to 7)
 00000378  48/ D3 EA						SHR				RDX, CL							; shift it right by 64 - bits to shift, putting first bits at low end of register
 0000037B  86 E9						XCHG			CH, CL							; switch CL from bits to shift right, to bits to shift left
 0000037D  49/ D3 E1						SHL				R9, CL							; Shift the zero (of 0 to 7) word left, truncating "top" bits
 00000380  86 E9						XCHG			CH, CL							; restore CL to the right shift number
 00000382  4C/ 0B CA						OR				R9, RDX							; "OR" in the low bits from the 6th word into the shifted seventh word
				;  . . . repeat for each word . . 
 00000385  49/ 8B D3						MOV				RDX, R11
 00000388  48/ D3 EA						SHR				RDX, CL
 0000038B  86 E9						XCHG			CH, CL
 0000038D  49/ D3 E2						SHL				R10, CL
 00000390  86 E9						XCHG			CH, CL
 00000392  4C/ 0B D2						OR				R10, RDX
								;
 00000395  49/ 8B D4						MOV				RDX, R12
 00000398  48/ D3 EA						SHR				RDX, CL
 0000039B  86 E9						XCHG			CH, CL
 0000039D  49/ D3 E3						SHL				R11, CL
 000003A0  86 E9						XCHG			CH, CL
 000003A2  4C/ 0B DA						OR				R11, RDX
								;
 000003A5  49/ 8B D5						MOV				RDX, R13
 000003A8  48/ D3 EA						SHR				RDX, CL
 000003AB  86 E9						XCHG			CH, CL
 000003AD  49/ D3 E4						SHL				R12, CL
 000003B0  86 E9						XCHG			CH, CL
 000003B2  4C/ 0B E2						OR				R12, RDX
								;
 000003B5  49/ 8B D6						MOV				RDX, R14
 000003B8  48/ D3 EA						SHR				RDX, CL
 000003BB  86 E9						XCHG			CH, CL
 000003BD  49/ D3 E5						SHL				R13, CL
 000003C0  86 E9						XCHG			CH, CL
 000003C2  4C/ 0B EA						OR				R13, RDX
								;
 000003C5  49/ 8B D7						MOV				RDX, R15
 000003C8  48/ D3 EA						SHR				RDX, CL
 000003CB  86 E9						XCHG			CH, CL
 000003CD  49/ D3 E6						SHL				R14, CL
 000003D0  86 E9						XCHG			CH, CL
 000003D2  4C/ 0B F2						OR				R14, RDX
								;
 000003D5  48/ 8B D7						MOV				RDX, RDI
 000003D8  48/ D3 EA						SHR				RDX, CL
 000003DB  86 E9						XCHG			CH, CL
 000003DD  49/ D3 E7						SHL				R15, CL
 000003E0  4C/ 0B FA						OR				R15, RDX
				; no bits to OR in on the index 0 (high order) word, just shift it.
 000003E3  48/ D3 E7						SHL				RDI, CL
 000003E6			@@nobits:
				; with the bits shifted within the words, if the desired shift is more than 64 bits, word shifts are required
				; verify Nr of word shift is zero to seven, use it as index into jump table; jump to appropriate shift
 000003E6  66| 41/ C1 E8					SHR				R8W, 6
	   06
 000003EB  49/ 83 E0 07						AND				R8, 07h 
 000003EF  66| 41/ C1 E0					SHL				R8W, 3
	   03
 000003F4  48/ 8D 05						LEA				RAX, @@jtbl
	   00000405 R
 000003FB  4C/ 03 C0						ADD				R8, RAX
 000003FE  48/ 33 C0						XOR				RAX, RAX						; clear rax for use as zeroing words shifted "in"
 00000401  59							POP				RCX								; restore RCX, destination address
 00000402  41/ FF 20						JMP				Q_PTR [ R8 ]
 00000405			@@jtbl:
 00000405  0000000000000445 R					QWORD			@@0, @@1, @@2, @@3, @@4, @@5, @@6, @@7
	   0000000000000469 R
	   000000000000048D R
	   00000000000004B1 R
	   00000000000004D5 R
	   00000000000004F6 R
	   0000000000000517 R
	   0000000000000538 R
				; no word shift, just bits, so store words in destination in the same order as they are
 00000445			@@0:			
 00000445  4C/ 89 09						MOV				Q_PTR [ RCX ] [ 0 * 8 ], R9
 00000448  4C/ 89 51 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], R10
 0000044C  4C/ 89 59 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], R11
 00000450  4C/ 89 61 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], R12
 00000454  4C/ 89 69 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], R13
 00000458  4C/ 89 71 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], R14
 0000045C  4C/ 89 79 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], R15
 00000460  48/ 89 79 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], RDI	
 00000464  E9 000000EE						JMP				@@R
				; one word shift, shifting one word (64+ bits) so store words in destination shifted left one, fill with zero
 00000469			@@1:			
 00000469  4C/ 89 11						MOV				Q_PTR [ RCX ] [ 0 * 8 ], R10
 0000046C  4C/ 89 59 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], R11
 00000470  4C/ 89 61 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], R12
 00000474  4C/ 89 69 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], R13
 00000478  4C/ 89 71 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], R14
 0000047C  4C/ 89 79 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], R15
 00000480  48/ 89 79 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], RDI
 00000484  48/ 89 41 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX	
 00000488  E9 000000CA						JMP				@@R
				; two word shift
 0000048D			@@2:			
 0000048D  4C/ 89 19						MOV				Q_PTR [ RCX ] [ 0 * 8], R11
 00000490  4C/ 89 61 08						MOV				Q_PTR [ RCX ] [ 1 * 8], R12
 00000494  4C/ 89 69 10						MOV				Q_PTR [ RCX ] [ 2 * 8], R13
 00000498  4C/ 89 71 18						MOV				Q_PTR [ RCX ] [ 3 * 8], R14
 0000049C  4C/ 89 79 20						MOV				Q_PTR [ RCX ] [ 4 * 8], R15
 000004A0  48/ 89 79 28						MOV				Q_PTR [ RCX ] [ 5 * 8], RDI
 000004A4  48/ 89 41 30						MOV				Q_PTR [ RCX ] [ 6 * 8], RAX
 000004A8  48/ 89 41 38						MOV				Q_PTR [ RCX ] [ 7 * 8], RAX	
 000004AC  E9 000000A6						JMP				@@R
				; three word shift
 000004B1			@@3:			
 000004B1  4C/ 89 21						MOV				Q_PTR [ RCX ] [ 0 * 8 ], R12
 000004B4  4C/ 89 69 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], R13
 000004B8  4C/ 89 71 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], R14
 000004BC  4C/ 89 79 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], R15
 000004C0  48/ 89 79 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], RDI
 000004C4  48/ 89 41 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 000004C8  48/ 89 41 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 000004CC  48/ 89 41 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX	
 000004D0  E9 00000082						JMP				@@R
				; four word shift
 000004D5			@@4:			
 000004D5  4C/ 89 29						MOV				Q_PTR [ RCX ] [ 0 * 8 ], R13
 000004D8  4C/ 89 71 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], R14
 000004DC  4C/ 89 79 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], R15
 000004E0  48/ 89 79 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], RDI
 000004E4  48/ 89 41 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 000004E8  48/ 89 41 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 000004EC  48/ 89 41 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 000004F0  48/ 89 41 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX	
 000004F4  EB 61						JMP				@@R
				; five word shift
 000004F6			@@5:			
 000004F6  4C/ 89 31						MOV				Q_PTR [ RCX ] [ 0 * 8 ], R14
 000004F9  4C/ 89 79 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], R15
 000004FD  48/ 89 79 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], RDI
 00000501  48/ 89 41 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 00000505  48/ 89 41 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 00000509  48/ 89 41 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 0000050D  48/ 89 41 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 00000511  48/ 89 41 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX	
 00000515  EB 40						JMP				@@R
				; six word shift
 00000517			@@6:			
 00000517  4C/ 89 39						MOV				Q_PTR [ RCX ] [ 0 * 8], R15
 0000051A  48/ 89 79 08						MOV				Q_PTR [ RCX ] [ 1 * 8], RDI
 0000051E  48/ 89 41 10						MOV				Q_PTR [ RCX ] [ 2 * 8], RAX
 00000522  48/ 89 41 18						MOV				Q_PTR [ RCX ] [ 3 * 8], RAX
 00000526  48/ 89 41 20						MOV				Q_PTR [ RCX ] [ 4 * 8], RAX
 0000052A  48/ 89 41 28						MOV				Q_PTR [ RCX ] [ 5 * 8], RAX
 0000052E  48/ 89 41 30						MOV				Q_PTR [ RCX ] [ 6 * 8], RAX
 00000532  48/ 89 41 38						MOV				Q_PTR [ RCX ] [ 7 * 8], RAX	
 00000536  EB 1F						JMP				@@R
				; seven word shift
 00000538			@@7:			
 00000538  48/ 89 39						MOV				Q_PTR [ RCX ] [ 0 * 8 ], RDI
 0000053B  48/ 89 41 08						MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 0000053F  48/ 89 41 10						MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 00000543  48/ 89 41 18						MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 00000547  48/ 89 41 20						MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 0000054B  48/ 89 41 28						MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 0000054F  48/ 89 41 30						MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 00000553  48/ 89 41 38						MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX
				;	restore non-volatile regs to as-called condition
 00000557			@@R:		
 00000557  5F							POP				RDI
 00000558  41/ 5F						POP				R15
 0000055A  41/ 5E						POP				R14
 0000055C  41/ 5D						POP				R13
 0000055E  41/ 5C						POP				R12
 00000560			@@ret:
 00000560  C3							RET

					ENDIF
								Leaf_End		shl_u, ui512
 00000561		     1	shl_u			ENDP
 00000561		     1	ui512			ENDS


				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			and_u		-	logical 'AND' bits in lh_op, rh_op, put result in destination
				;			Prototype:		void and_u( u64* destination, u64* lh_op, u64* rh_op);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			lh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			rh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in R8)
				;			returns		-	nothing (0)
								Leaf_Entry		and_u, ui512
 00000561		     1	ui512			SEGMENT			PARA 'CODE'
 00000561  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000570		     1	and_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX
								CheckAlign		R8

					IF __UseZ	
					ELSE
								FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
								MOV				RAX, Q_PTR [ RDX ] [ idx * 8 ]
								AND				RAX, Q_PTR [ R8 ] [ idx * 8 ]
								MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
								ENDM
 00000570  48/ 8B 02	     1					MOV				RAX, Q_PTR [ RDX ] [ 0 * 8 ]
 00000573  49/ 23 00	     1					AND				RAX, Q_PTR [ R8 ] [ 0 * 8 ]
 00000576  48/ 89 01	     1					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 00000579  48/ 8B 42 08	     1					MOV				RAX, Q_PTR [ RDX ] [ 1 * 8 ]
 0000057D  49/ 23 40 08	     1					AND				RAX, Q_PTR [ R8 ] [ 1 * 8 ]
 00000581  48/ 89 41 08	     1					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 00000585  48/ 8B 42 10	     1					MOV				RAX, Q_PTR [ RDX ] [ 2 * 8 ]
 00000589  49/ 23 40 10	     1					AND				RAX, Q_PTR [ R8 ] [ 2 * 8 ]
 0000058D  48/ 89 41 10	     1					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 00000591  48/ 8B 42 18	     1					MOV				RAX, Q_PTR [ RDX ] [ 3 * 8 ]
 00000595  49/ 23 40 18	     1					AND				RAX, Q_PTR [ R8 ] [ 3 * 8 ]
 00000599  48/ 89 41 18	     1					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 0000059D  48/ 8B 42 20	     1					MOV				RAX, Q_PTR [ RDX ] [ 4 * 8 ]
 000005A1  49/ 23 40 20	     1					AND				RAX, Q_PTR [ R8 ] [ 4 * 8 ]
 000005A5  48/ 89 41 20	     1					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 000005A9  48/ 8B 42 28	     1					MOV				RAX, Q_PTR [ RDX ] [ 5 * 8 ]
 000005AD  49/ 23 40 28	     1					AND				RAX, Q_PTR [ R8 ] [ 5 * 8 ]
 000005B1  48/ 89 41 28	     1					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 000005B5  48/ 8B 42 30	     1					MOV				RAX, Q_PTR [ RDX ] [ 6 * 8 ]
 000005B9  49/ 23 40 30	     1					AND				RAX, Q_PTR [ R8 ] [ 6 * 8 ]
 000005BD  48/ 89 41 30	     1					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 000005C1  48/ 8B 42 38	     1					MOV				RAX, Q_PTR [ RDX ] [ 7 * 8 ]
 000005C5  49/ 23 40 38	     1					AND				RAX, Q_PTR [ R8 ] [ 7 * 8 ]
 000005C9  48/ 89 41 38	     1					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX

					ENDIF
 000005CD  C3							RET		
								Leaf_End		and_u, ui512
 000005CE		     1	and_u			ENDP
 000005CE		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			or_u		-	logical 'OR' bits in lh_op, rh_op, put result in destination
				;			Prototype:		void or_u( u64* destination, u64* lh_op, u64* rh_op);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			lh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			rh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in R8)
				;			returns		-	nothing (0)

								Leaf_Entry		or_u, ui512
 000005CE		     1	ui512			SEGMENT			PARA 'CODE'
 000005CE  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000005E0		     1	or_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX
								CheckAlign		R8

					IF __UseZ	
					ELSE
								FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
								MOV				RAX, Q_PTR [ RDX ] [ idx * 8 ]
								OR				RAX,  Q_PTR [ R8 ] [ idx * 8 ]
								MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
								ENDM
 000005E0  48/ 8B 02	     1					MOV				RAX, Q_PTR [ RDX ] [ 0 * 8 ]
 000005E3  49/ 0B 00	     1					OR				RAX,  Q_PTR [ R8 ] [ 0 * 8 ]
 000005E6  48/ 89 01	     1					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 000005E9  48/ 8B 42 08	     1					MOV				RAX, Q_PTR [ RDX ] [ 1 * 8 ]
 000005ED  49/ 0B 40 08	     1					OR				RAX,  Q_PTR [ R8 ] [ 1 * 8 ]
 000005F1  48/ 89 41 08	     1					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 000005F5  48/ 8B 42 10	     1					MOV				RAX, Q_PTR [ RDX ] [ 2 * 8 ]
 000005F9  49/ 0B 40 10	     1					OR				RAX,  Q_PTR [ R8 ] [ 2 * 8 ]
 000005FD  48/ 89 41 10	     1					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 00000601  48/ 8B 42 18	     1					MOV				RAX, Q_PTR [ RDX ] [ 3 * 8 ]
 00000605  49/ 0B 40 18	     1					OR				RAX,  Q_PTR [ R8 ] [ 3 * 8 ]
 00000609  48/ 89 41 18	     1					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 0000060D  48/ 8B 42 20	     1					MOV				RAX, Q_PTR [ RDX ] [ 4 * 8 ]
 00000611  49/ 0B 40 20	     1					OR				RAX,  Q_PTR [ R8 ] [ 4 * 8 ]
 00000615  48/ 89 41 20	     1					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 00000619  48/ 8B 42 28	     1					MOV				RAX, Q_PTR [ RDX ] [ 5 * 8 ]
 0000061D  49/ 0B 40 28	     1					OR				RAX,  Q_PTR [ R8 ] [ 5 * 8 ]
 00000621  48/ 89 41 28	     1					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 00000625  48/ 8B 42 30	     1					MOV				RAX, Q_PTR [ RDX ] [ 6 * 8 ]
 00000629  49/ 0B 40 30	     1					OR				RAX,  Q_PTR [ R8 ] [ 6 * 8 ]
 0000062D  48/ 89 41 30	     1					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 00000631  48/ 8B 42 38	     1					MOV				RAX, Q_PTR [ RDX ] [ 7 * 8 ]
 00000635  49/ 0B 40 38	     1					OR				RAX,  Q_PTR [ R8 ] [ 7 * 8 ]
 00000639  48/ 89 41 38	     1					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX

					ENDIF
 0000063D  C3							RET 
								Leaf_End		or_u, ui512
 0000063E		     1	or_u			ENDP
 0000063E		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			xor_u		-	logical 'XOR' bits in lh_op, rh_op, put result in destination
				;			Prototype:		void or_u( u64* destination, u64* lh_op, u64* rh_op);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			lh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			rh_op		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in R8)
				;			returns		-	nothing (0)

								Leaf_Entry		xor_u, ui512
 0000063E		     1	ui512			SEGMENT			PARA 'CODE'
 0000063E  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000650		     1	xor_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX
								CheckAlign		R8

					IF __UseZ	
					ELSE
								FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
								MOV				RAX, Q_PTR [ RDX ] [ idx * 8 ]
								XOR				RAX,  Q_PTR [ R8 ] [ idx * 8 ]
								MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
								ENDM
 00000650  48/ 8B 02	     1					MOV				RAX, Q_PTR [ RDX ] [ 0 * 8 ]
 00000653  49/ 33 00	     1					XOR				RAX,  Q_PTR [ R8 ] [ 0 * 8 ]
 00000656  48/ 89 01	     1					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 00000659  48/ 8B 42 08	     1					MOV				RAX, Q_PTR [ RDX ] [ 1 * 8 ]
 0000065D  49/ 33 40 08	     1					XOR				RAX,  Q_PTR [ R8 ] [ 1 * 8 ]
 00000661  48/ 89 41 08	     1					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 00000665  48/ 8B 42 10	     1					MOV				RAX, Q_PTR [ RDX ] [ 2 * 8 ]
 00000669  49/ 33 40 10	     1					XOR				RAX,  Q_PTR [ R8 ] [ 2 * 8 ]
 0000066D  48/ 89 41 10	     1					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 00000671  48/ 8B 42 18	     1					MOV				RAX, Q_PTR [ RDX ] [ 3 * 8 ]
 00000675  49/ 33 40 18	     1					XOR				RAX,  Q_PTR [ R8 ] [ 3 * 8 ]
 00000679  48/ 89 41 18	     1					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 0000067D  48/ 8B 42 20	     1					MOV				RAX, Q_PTR [ RDX ] [ 4 * 8 ]
 00000681  49/ 33 40 20	     1					XOR				RAX,  Q_PTR [ R8 ] [ 4 * 8 ]
 00000685  48/ 89 41 20	     1					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 00000689  48/ 8B 42 28	     1					MOV				RAX, Q_PTR [ RDX ] [ 5 * 8 ]
 0000068D  49/ 33 40 28	     1					XOR				RAX,  Q_PTR [ R8 ] [ 5 * 8 ]
 00000691  48/ 89 41 28	     1					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 00000695  48/ 8B 42 30	     1					MOV				RAX, Q_PTR [ RDX ] [ 6 * 8 ]
 00000699  49/ 33 40 30	     1					XOR				RAX,  Q_PTR [ R8 ] [ 6 * 8 ]
 0000069D  48/ 89 41 30	     1					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 000006A1  48/ 8B 42 38	     1					MOV				RAX, Q_PTR [ RDX ] [ 7 * 8 ]
 000006A5  49/ 33 40 38	     1					XOR				RAX,  Q_PTR [ R8 ] [ 7 * 8 ]
 000006A9  48/ 89 41 38	     1					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX

					ENDIF
 000006AD  C3							RET 
								Leaf_End		xor_u, ui512
 000006AE		     1	xor_u			ENDP
 000006AE		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			not_u		-	logical 'NOT' bits in source, put result in destination
				;			Prototype:		void not_u( u64* destination, u64* source);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			returns		-	nothing (0)

								Leaf_Entry		not_u, ui512
 000006AE		     1	ui512			SEGMENT			PARA 'CODE'
 000006AE  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000006C0		     1	not_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX

					IF __UseZ	
					ELSE
								FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
								MOV				RAX, Q_PTR [ RDX ] [ idx * 8 ]
								NOT				RAX
								MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
								ENDM
 000006C0  48/ 8B 02	     1					MOV				RAX, Q_PTR [ RDX ] [ 0 * 8 ]
 000006C3  48/ F7 D0	     1					NOT				RAX
 000006C6  48/ 89 01	     1					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 000006C9  48/ 8B 42 08	     1					MOV				RAX, Q_PTR [ RDX ] [ 1 * 8 ]
 000006CD  48/ F7 D0	     1					NOT				RAX
 000006D0  48/ 89 41 08	     1					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 000006D4  48/ 8B 42 10	     1					MOV				RAX, Q_PTR [ RDX ] [ 2 * 8 ]
 000006D8  48/ F7 D0	     1					NOT				RAX
 000006DB  48/ 89 41 10	     1					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 000006DF  48/ 8B 42 18	     1					MOV				RAX, Q_PTR [ RDX ] [ 3 * 8 ]
 000006E3  48/ F7 D0	     1					NOT				RAX
 000006E6  48/ 89 41 18	     1					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 000006EA  48/ 8B 42 20	     1					MOV				RAX, Q_PTR [ RDX ] [ 4 * 8 ]
 000006EE  48/ F7 D0	     1					NOT				RAX
 000006F1  48/ 89 41 20	     1					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 000006F5  48/ 8B 42 28	     1					MOV				RAX, Q_PTR [ RDX ] [ 5 * 8 ]
 000006F9  48/ F7 D0	     1					NOT				RAX
 000006FC  48/ 89 41 28	     1					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 00000700  48/ 8B 42 30	     1					MOV				RAX, Q_PTR [ RDX ] [ 6 * 8 ]
 00000704  48/ F7 D0	     1					NOT				RAX
 00000707  48/ 89 41 30	     1					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 0000070B  48/ 8B 42 38	     1					MOV				RAX, Q_PTR [ RDX ] [ 7 * 8 ]
 0000070F  48/ F7 D0	     1					NOT				RAX
 00000712  48/ 89 41 38	     1					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX

					ENDIF
 00000716  C3							RET	
								Leaf_End		not_u, ui512
 00000717		     1	not_u			ENDP
 00000717		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			msb_u		-	find most significant bit in supplied source 512bit (8 QWORDS)
				;			Prototype:		s16 msb_u( u64* source );
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			returns		-	-1 if no most significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
				;			Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit)
				;					a returned 511 means bit63 of the first word (the left most bit)

								Leaf_Entry		msb_u, ui512
 00000717		     1	ui512			SEGMENT			PARA 'CODE'
 00000717  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000720		     1	msb_u			PROC			FRAME
								CheckAlign		RCX								; (IN) source to scan 

					IF __UseZ
					ELSE
 00000720  4C/ 8D 14 25						LEA				R10, [ -1 ]						; Initialize loop counter (and index)
	   FFFFFFFF
 00000728			@@NextWord:
 00000728  41/ FF C2						INC				R10D
 0000072B  41/ 83 FA 08						CMP				R10D, 8
 0000072F  75 08						JNZ				@F								; Loop through values 0 to 7, then exit
 00000731  8D 04 25						LEA				EAX,  [ retcode_neg_one ]
	   FFFFFFFF
 00000738  C3							RET
 00000739			@@:
 00000739  F3/ 4E/ 0F BD 1C					LZCNT			R11, Q_PTR [ RCX ] [ R10 * 8 ]	; Leading zero count to find significant bit for index 
	   D1
 0000073F  72 E7						JC				@@NextWord						; None found, loop to next word
 00000741  8D 04 25						LEA				EAX, [ 7 ]
	   00000007
 00000748  41/ 2B C2						SUB				EAX, R10D						; calculate seven minus the word index (which word has the msb?)
 0000074B  C1 E0 06						SHL				EAX, 6							; times 64 for each word
 0000074E  8D 0C 25						LEA				ECX, [ 63 ]
	   0000003F
 00000755  41/ 2B CB						SUB				ECX, R11D
 00000758  03 C1						ADD				EAX, ECX						; plus the found bit position within the word yields the bit position within the 512 bit source
 0000075A  C3							RET	

					ENDIF

								Leaf_End		msb_u, ui512
 0000075B		     1	msb_u			ENDP
 0000075B		     1	ui512			ENDS

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			lsb_u		-	find least significant bit in supplied source 512bit (8 QWORDS)
				;			Prototype:		s16 lsb_u( u64* source );
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			returns		-	-1 if no least significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
				;			Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit)
				;					a returned 511 means bit63 of the first word (the left most bit)

								Leaf_Entry		lsb_u, ui512				
 0000075B		     1	ui512			SEGMENT			PARA 'CODE'
 0000075B  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000770		     1	lsb_u			PROC			FRAME
								CheckAlign		RCX								; (IN) source to scan

					IF __UseZ
					ELSE
 00000770  4C/ 8D 14 25						LEA				R10, [ 8 ]		 				; Initialize loop counter (and index)
	   00000008
 00000778			@@NextWord:
 00000778  41/ FF CA						DEC				R10D
 0000077B  41/ 83 FA FF						CMP				R10D, -1
 0000077F  75 08						JNE				@F								; Loop through values 7 to 0, then exit
 00000781  8D 04 25						LEA				EAX, [ retcode_neg_one ]
	   FFFFFFFF
 00000788  C3							RET
 00000789			@@:
 00000789  F3/ 4A/ 0F BC 04					TZCNT			RAX, Q_PTR [ RCX ] [ R10 * 8 ]	; Scan indexed word for significant bit
	   D1
 0000078F  72 E7						JC				@@NextWord						; None found, loop to next word
 00000791  44/ 8D 1C 25						LEA				R11D, [ 7 ]						;  
	   00000007
 00000799  45/ 2B DA						SUB				R11D, R10D						; calculate seven minus the word index (which word has the msb?)
 0000079C  41/ C1 E3 06						SHL				R11D, 6							; times 64 for each word
 000007A0  41/ 03 C3						ADD				EAX, R11D						; plus the BSF found bit position within the word yields the bit position within the 512 bit source
 000007A3  C3							RET

					ENDIF
								Leaf_End		lsb_u, ui512
 000007A4		     1	lsb_u			ENDP
 000007A4		     1	ui512			ENDS

				END
Microsoft (R) Macro Assembler (x64) Version 14.44.35214.0   08/17/25 22:33:01
ui512b.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

CheckAlign . . . . . . . . . . .	Proc
Copy512Q . . . . . . . . . . . .	Proc
Copy512  . . . . . . . . . . . .	Proc
Leaf_End . . . . . . . . . . . .	Proc
Leaf_Entry . . . . . . . . . . .	Proc
MemConstants . . . . . . . . . .	Proc
ShiftOrR . . . . . . . . . . . .	Proc
VerifyRegs . . . . . . . . . . .	Proc
Zero512Q . . . . . . . . . . . .	Proc
Zero512  . . . . . . . . . . . .	Proc


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

kMask  . . . . . . . . . . . . .	 00000009      00000009
  b8 . . . . . . . . . . . . . .	 00000008      00000001	     0100     ?
  b7 . . . . . . . . . . . . . .	 00000007      00000001	     0080     ?
  b6 . . . . . . . . . . . . . .	 00000006      00000001	     0040     ?
  b5 . . . . . . . . . . . . . .	 00000005      00000001	     0020     ?
  b4 . . . . . . . . . . . . . .	 00000004      00000001	     0010     ?
  b3 . . . . . . . . . . . . . .	 00000003      00000001	     0008     ?
  b2 . . . . . . . . . . . . . .	 00000002      00000001	     0004     ?
  b1 . . . . . . . . . . . . . .	 00000001      00000001	     0002     ?
  b0 . . . . . . . . . . . . . .	 00000000      00000001	     0001     ?


Types:

                N a m e                  Size     Attr

LPVOID . . . . . . . . . . . . .	 00000008     PTR VOID


Segments:

                N a m e                  Length   Align   Class

ui512D . . . . . . . . . . . . .	 0000005D 64	  'DATA'	
ui512  . . . . . . . . . . . . .	 000007A4 16	  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

and_u  . . . . . . . . . . . . .	P 	 00000570 ui512	Length= 0000005E Public
lsb_u  . . . . . . . . . . . . .	P 	 00000770 ui512	Length= 00000034 Public
  @@NextWord . . . . . . . . . .	L 	 00000778 ui512	
msb_u  . . . . . . . . . . . . .	P 	 00000720 ui512	Length= 0000003B Public
  @@NextWord . . . . . . . . . .	L 	 00000728 ui512	
not_u  . . . . . . . . . . . . .	P 	 000006C0 ui512	Length= 00000057 Public
or_u . . . . . . . . . . . . . .	P 	 000005E0 ui512	Length= 0000005E Public
shl_u  . . . . . . . . . . . . .	P 	 000002B0 ui512	Length= 000002B1 Public
  @@r  . . . . . . . . . . . . .	L 	 00000327 ui512	
  @@nobits . . . . . . . . . . .	L 	 000003E6 ui512	
  @@jtbl . . . . . . . . . . . .	L 	 00000405 ui512	
  @@0  . . . . . . . . . . . . .	L 	 00000445 ui512	
  @@1  . . . . . . . . . . . . .	L 	 00000469 ui512	
  @@2  . . . . . . . . . . . . .	L 	 0000048D ui512	
  @@3  . . . . . . . . . . . . .	L 	 000004B1 ui512	
  @@4  . . . . . . . . . . . . .	L 	 000004D5 ui512	
  @@5  . . . . . . . . . . . . .	L 	 000004F6 ui512	
  @@6  . . . . . . . . . . . . .	L 	 00000517 ui512	
  @@7  . . . . . . . . . . . . .	L 	 00000538 ui512	
  @@R  . . . . . . . . . . . . .	L 	 00000557 ui512	
  @@ret  . . . . . . . . . . . .	L 	 00000560 ui512	
shr_u  . . . . . . . . . . . . .	P 	 00000010 ui512	Length= 00000292 Public
  @@ret  . . . . . . . . . . . .	L 	 00000087 ui512	
  @@nobits . . . . . . . . . . .	L 	 00000126 ui512	
  jtbl . . . . . . . . . . . . .	L 	 00000146 ui512	
  S0 . . . . . . . . . . . . . .	L 	 00000186 ui512	
  S1 . . . . . . . . . . . . . .	L 	 000001AA ui512	
  S2 . . . . . . . . . . . . . .	L 	 000001CE ui512	
  S3 . . . . . . . . . . . . . .	L 	 000001F2 ui512	
  S4 . . . . . . . . . . . . . .	L 	 00000216 ui512	
  S5 . . . . . . . . . . . . . .	L 	 00000237 ui512	
  S6 . . . . . . . . . . . . . .	L 	 00000258 ui512	
  S7 . . . . . . . . . . . . . .	L 	 00000279 ui512	
  @@R  . . . . . . . . . . . . .	L 	 00000298 ui512	
xor_u  . . . . . . . . . . . . .	P 	 00000650 ui512	Length= 0000005E Public


Symbols:

                N a m e                 Type     Value    Attr

$xdatasym  . . . . . . . . . . .	Byte	 00000000 _XDATA	
B_PTR  . . . . . . . . . . . . .	Text   	 BYTE PTR
CPEQ . . . . . . . . . . . . . .	Number	 00000000h   
CPFALSE  . . . . . . . . . . . .	Number	 00000003h   
CPGE . . . . . . . . . . . . . .	Number	 00000005h   
CPGT . . . . . . . . . . . . . .	Number	 00000006h   
CPLE . . . . . . . . . . . . . .	Number	 00000002h   
CPLT . . . . . . . . . . . . . .	Number	 00000001h   
CPNE . . . . . . . . . . . . . .	Number	 00000004h   
CPTRUE . . . . . . . . . . . . .	Number	 00000007h   
D_PTR  . . . . . . . . . . . . .	Text   	 DWORD PTR
Q_PTR  . . . . . . . . . . . . .	Text   	 QWORD PTR
W_PTR  . . . . . . . . . . . . .	Text   	 WORD PTR
XM_PTR . . . . . . . . . . . . .	Text   	 XMMWORD PTR
YM_PTR . . . . . . . . . . . . .	Text   	 YMMWORD PTR
ZM_PTR . . . . . . . . . . . . .	Text   	 ZMMWORD PTR
__CheckAlign . . . . . . . . . .	Number	 00000000h   
__UseBMI2  . . . . . . . . . . .	Number	 00000001h   
__UseQ . . . . . . . . . . . . .	Number	 00000001h   
__UseX . . . . . . . . . . . . .	Number	 00000000h   
__UseY . . . . . . . . . . . . .	Number	 00000000h   
__UseZ . . . . . . . . . . . . .	Number	 00000000h   
__VerifyRegs . . . . . . . . . .	Number	 00000001h   
add_uT64 . . . . . . . . . . . .	L 	 00000000 External
add_u  . . . . . . . . . . . . .	L 	 00000000 External
compare_uT64 . . . . . . . . . .	L 	 00000000 External
compare_u  . . . . . . . . . . .	L 	 00000000 External
compile_time_options_INC . . . .	Text   	 1
copy_u . . . . . . . . . . . . .	L 	 00000000 External
legalnotes . . . . . . . . . . .	Number	 00000001h   
m32BCST  . . . . . . . . . . . .	Text   	 DWORD BCST
m64BCST  . . . . . . . . . . . .	Text   	 QWORD BCST
mskAll8  . . . . . . . . . . . .	Byte	 0000005C ui512D	
mskB0  . . . . . . . . . . . . .	Byte	 00000054 ui512D	
mskB1  . . . . . . . . . . . . .	Byte	 00000055 ui512D	
mskB2  . . . . . . . . . . . . .	Byte	 00000056 ui512D	
mskB3  . . . . . . . . . . . . .	Byte	 00000057 ui512D	
mskB4  . . . . . . . . . . . . .	Byte	 00000058 ui512D	
mskB5  . . . . . . . . . . . . .	Byte	 00000059 ui512D	
mskB6  . . . . . . . . . . . . .	Byte	 0000005A ui512D	
mskB7  . . . . . . . . . . . . .	Byte	 0000005B ui512D	
qOnes  . . . . . . . . . . . . .	QWord	 00000000 ui512D	
reg_verify . . . . . . . . . . .	L 	 00000000 External
ret_neg_one  . . . . . . . . . .	DWord	 00000050 ui512D	
ret_one  . . . . . . . . . . . .	DWord	 0000004C ui512D	
ret_zero . . . . . . . . . . . .	DWord	 00000048 ui512D	
retcode_neg_one  . . . . . . . .	Number	 -00000001h   
retcode_one  . . . . . . . . . .	Number	 00000001h   
retcode_zero . . . . . . . . . .	Number	 00000000h   
set_uT64 . . . . . . . . . . . .	L 	 00000000 External
sub_uT64 . . . . . . . . . . . .	L 	 00000000 External
sub_u  . . . . . . . . . . . . .	L 	 00000000 External
ui512aMacros_INC . . . . . . . .	Text   	 1
ui512bMacros_INC . . . . . . . .	Text   	 1
zeroQ  . . . . . . . . . . . . .	QWord	 00000040 ui512D	
zero_u . . . . . . . . . . . . .	L 	 00000000 External

	   0 Warnings
	   0 Errors
